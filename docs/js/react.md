# React

## Что такое React

- **Библиотека для описания UI на JS**: ты описываешь что должно быть на экране для текущего состояния, а как применить
  изменения решает React.
- **Декларативность + Компонентый подход**: UI собирается из мелких переиспользуемых компонентов.
- Однонаправленные данные: props вниз, события (коллбеки) вверх; локальный state и при необходимости - контекст.
- **JSX синтаксис** -- это сахар над вызовами создания элементов (можно писать и без JSX).
- **Среда-агностичность**: ядро react не знает про DOM/платформу; отрисовку выполняет рендерер (React-DOM -- web,
  React-Native -- iOS/Android, CLI и т.д.). Идея: React Core описывает дерево UI и жизненный цикл, а конкретный рендерер
  знает как применить изменения в своей среде.
- React - не зависим от бразуера, React dom - отвечает за отрисовку в браузере.
- Предсказуемые обновления: изменение состояния -- React пересчитывает дерево UI и вносит минимальные правки в целевую
  среду.
- Не фреймворк: маршрутизация, глобальное состояние, данные, сборка — по выбору разработчика; React решает именно слой
  UI.
- React предоставляет разработку SPA приложений (html мы не пишем, мы пишем js, изначально происходит загрузка всего js
  всего сайта, и js на клиенте меняет html и приложение работает потом на клиенте быстрее) (без библиотеки - часто надо
  взаимодействовать с DOM деревом, получить элемент по классу по ид, добавить слушатели, удалить добавить и надо думать
  больше о том что куда добавить и что где добавить -- больше ошибки и больше времени, + все операции над DOM деревом
  ресурсоемки реакт сам следит за управлением дом деревом)

## React Хуки

- useState()
- useEffect()
- useLayoutEffect()
- useRef()
- useMemo()
- useCallback()
- useContext()

# Тема для разбора

- Хуки (useState)
- props (children, ...props)
- Жизненный цикл компонента (монтирование, обновление, размонтирование)
- крутилка при fetch загрузке const loading, useLoading = useState() -- обычно выводится в отдельный кастомный хук и
  каждый fetch оборачивать
- обмен данными между компонентами -- всегда сверху вниз, но если надо снизу вверх - то callback в пропс фунцию передать
- условная отрисовка (тернарный оператор)
- способы взаимодействия в jsx со стилями -- все варианты
- Архитектура и жизненный цикл: Fiber-дерево, фазы render/commit, планировщик, batching, приоритеты.
- Рендереры и роли: react-dom (клиент/SSR/гидратация/стриминг), react-native (Yoga/бридж), другие (CLI/WebGL),
  react-reconciler.
- JSX под капотом: jsx/jsxs, элементы, key, фрагменты.
- “Работа с DOM вручную” vs React: декларативность против императивных манипуляций, где выигрываем по надежности и
  стоимости изменений.
- SPA/SSR/CSR/гидратация: что такое SPA на React, когда нужен серверный рендеринг и как он сочетается с клиентом.
- Виртуальное представление UI и согласование: зачем внутреннее дерево, как находится минимальный патч, когда
  “виртуальный DOM” полезная метафора, а когда нет.
- Экосистема и сборка: Node.js как среда разработки, Vite/Webpack, транспиляция JSX/TS, dev-серверы, HMR.
- react router dom
- роутинг, редирект, useHistory, useParams
- приватные и публичные маршруты
- https://youtu.be/GNrdg3PzpJQ?t=9490
- https://youtu.be/GNrdg3PzpJQ?t=10031
- https://youtu.be/GNrdg3PzpJQ?t=6571
- https://youtu.be/GNrdg3PzpJQ?t=6385
- 
























