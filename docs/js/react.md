# React

## Что такое React

- **Библиотека для описания UI на JS**: ты описываешь что должно быть на экране для текущего состояния, а как применить
  изменения решает React.
- **Декларативность + Компонентый подход**: UI собирается из мелких переиспользуемых компонентов.
- Однонаправленные данные: props вниз, события (коллбеки) вверх; локальный state и при необходимости - контекст.
- **JSX синтаксис** -- это сахар над вызовами создания элементов (можно писать и без JSX).
- **Среда-агностичность**: ядро react не знает про DOM/платформу; отрисовку выполняет рендерер (React-DOM -- web,
  React-Native -- iOS/Android, CLI и т.д.). Идея: React Core описывает дерево UI и жизненный цикл, а конкретный рендерер
  знает как применить изменения в своей среде.
- React - не зависим от бразуера, React dom - отвечает за отрисовку в браузере.
- Предсказуемые обновления: изменение состояния -- React пересчитывает дерево UI и вносит минимальные правки в целевую
  среду.
- Не фреймворк: маршрутизация, глобальное состояние, данные, сборка — по выбору разработчика; React решает именно слой
  UI.
- React предоставляет разработку SPA приложений (html мы не пишем, мы пишем js, изначально происходит загрузка всего js
  всего сайта, и js на клиенте меняет html и приложение работает потом на клиенте быстрее) (без библиотеки - часто надо
  взаимодействовать с DOM деревом, получить элемент по классу по ид, добавить слушатели, удалить добавить и надо думать
  больше о том что куда добавить и что где добавить -- больше ошибки и больше времени, + все операции над DOM деревом
  ресурсоемки реакт сам следит за управлением дом деревом)

## Жизненный цикл компонента (монтирование, обновление, размонтирование)

Компонент — это функция, которая на вход получает свойства props и может хранить состояние state. Функция возвращает
описание интерфейса (JSX).

React берет это описание и показывает его в среде отображения (в браузере — в DOM).

За время работы страницы с компонентом происходит три типа событий:

1. Монтирование — компонент появляется впервые.
2. Обновление — что-то изменилось (props, state, контекст) и интерфейс надо пересчитать.
3. Размонтирование — компонент убирают с экрана.

Каждый раз, когда что-то из этих событий происходит, внутри есть два этапа:

- Рендер (render)
  Задача: понять, что должно быть на экране. Здесь нельзя изменять реальный интерфейс (DOM), ставить таймеры,
  подписываться на события — это “побочные действия”. Их место — эффекты. Render может повторяться (например, из-за
  планировщика или в режиме Strict Mode в разработке). Пока нет коммита, пользователь ничего не видит.
    - Вызывает функцию компонента как обычную JS-функцию.
    - Читает данные: свойства (props), состояние (state через useState/useReducer), контекст (useContext).
    - Выполняет мемоизации: useMemo/useCallback — берёт из кэша или пересчитывает, если зависимости изменились.
    - Формирует описание интерфейса (JSX → внутренняя структура элементов).
    - Сравнивает новое описание с предыдущим и готовит список изменений (“патч”), который нужно применить к реальному
      интерфейсу.

- Коммит (commit) - Задача: применить подготовленные изменения к реальному интерфейсу. Коммит происходит реже, чем
  рендер: если рендер прервали/переиграли, а изменений ещё не применяли, пользователь этого не увидит. Коммит всегда
  делает минимальные необходимые изменения (не “перерисовка всего”).
    - Мутации интерфейса: создать/удалить/переместить DOM-узлы, обновить атрибуты, повесить обработчики событий,
      назначить ref.
    - useLayoutEffect: сначала очистка старых, потом запуск новых — сразу после мутаций, до того как браузер покажет
      кадр. Здесь можно измерять размеры, ставить фокус, прокручивать без “морганий”.
    - Отрисовка кадра браузером (пользователь видит изменения).
    - useEffect: сначала очистка старых, потом запуск новых — после кадра. Здесь подписки, таймеры, запросы,
      логирование.

### Монтирование (компонент появляется впервые)

1. Рендер
   React вызывает вашу функцию-компонент. Здесь:
    - читаются props и state (если вы их завели через useState),
    - вычисляются мемоизации (useMemo, useCallback) — либо берется кеш, либо пересчет,
    - читается контекст (useContext),
    - возвращается JSX — описание того, что должно быть на экране.
2. Коммит
   React:
    - создает реальные DOM-узлы и вставляет их на страницу,
    - присваивает refs (объекты ref.current начинают указывать на DOM-элементы),
    - запускает синхронные эффекты разметки — useLayoutEffect. Это код, который должен выполниться сразу после вставки
      DOM, но до показа кадра. Например: измерить размеры блока и прокрутить к нему.
    - браузер рисует кадр (пользователь видит обновление),
    - запускает пассивные эффекты — useEffect. Это код, который можно выполнить “спокойно”, уже после кадра. Например:
      подписаться на веб-сокет, запустить таймер, отправить метрику.

**Что важно помнить**

- В рендере — только вычисления и возврат JSX.
- В useLayoutEffect — работа, которая должна произойти до отрисовки кадра (измерения, фокус без “морганий”).
- В useEffect — подписки, таймеры, запросы: то, что не должно блокировать кадр.

### Обновление (что-то изменилось)

**Сценарии обновления:**

- Изменились props -- Родитель передал другие значения
- Изменился state компонента -- Через setState/dispatch
- Изменилось значение контекста -- Любой потребитель useContext(MyContext) перерендерится, если MyContext.Provider дал
  новое value
- Перерисовался родитель -- По умолчанию дочерние компоненты тоже вызываются (Render), даже если их props формально те
  же. Как уменьшать это: React.memo у дочернего компонента + стабильные ссылки через useCallback/useMemo
- Изменился ключ (key) элемента в списке -- Для React это другой элемент → старый размонтируется, новый смонтируется (а
  не просто перерендерится).
- Внешние подписки/хранилища -- Библиотеки (Redux useSelector, useSyncExternalStore) под капотом вызывают setState в
  ваших компонентах.
- Навигация/состояние маршрута -- Смена маршрута меняет дерево компонентов → нужные части дерева рендерятся заново.
- Strict Mode (только Dev) -- Удваивает некоторые вызовы Render/cleanup, чтобы обнаружить ошибки сайд-эффектов (в
  продакшене этого нет).

1. Рендер
   Компонент снова вызывается как функция:
    - читается новое состояние/новые свойства,
    - useMemo/useCallback либо отдают кеш, либо пересчитываются (если зависимости изменились),
    - возвращается новый JSX.

2. Коммит
   React:
    - находит минимальный набор изменений в реальном интерфейсе (вставить/удалить/изменить только то, что действительно
      поменялось),
    - очищает старые useLayoutEffect (выполняет функции-очистки, которые вы вернули из useLayoutEffect ранее),
    - применяет изменения к DOM, заново присваивает ref,
    - запускает новые useLayoutEffect,
    - браузер рисует кадр,
    - очищает старые useEffect (если зависимости у эффекта изменились),
    - запускает новые useEffect.

**Что важно помнить**

- Если в useEffect вы вернули функцию-очистку, она обязательно выполнится перед следующим запуском этого же эффекта (и
  при размонтировании).
- Частая ошибка: в useEffect без условий вы вызываете setState → это снова вызывает эффект → бесконечный цикл. Следите
  за массивом зависимостей второго аргумента.

### Размонтирование (компонент удаляют)

Размонтирование == компонент больше не находится в дереве интерфейса.

**Сценарии размонтирования:**

- Условный рендеринг перестал быть истинным (`{isOpen ? <Modal/> : null} // isOpen стал false → <Modal/> размонтирован`)
- Списки: элемент исчез из данных
- Смена ключа (key) у элемента
- Навигация/смена маршрута -- Переход на другую страницу убирает часть дерева → эти компоненты размонтированы.
- Error Boundary “поймал” ошибку в поддереве -- Ветвь с ошибкой размонтируется и заменяется запасным UI (fallback).
- Разворот/сворачивание через состояние -- Любое изменение состояния/контекста/пропсов, которое приводит к тому, что
  компонент больше не возвращается из JSX родителя.

**Что не является размонтированием:**

- Скрытие через CSS (`display: none, visibility: hidden`) — узел остаётся в дереве, это не unmount.
- Очистка содержимого компонента (например, `<div />` вместо `<div>…</div>`) — сам компонент остаётся смонтирован.

1. Коммит
    - удаляются DOM-узлы компонента,
    - вызываются очистки useLayoutEffect,
    - затем вызываются очистки useEffect,
    - ref.current перестает указывать на DOM-элементы (становится null, если это DOM-ref).

**Что важно помнить**

- Все подписки, таймеры, наблюдатели нужно снимать/останавливать в функциях-очистках, которые вы возвращаете из
  useEffect/useLayoutEffect. Тогда ресурсы не будут “утекать”.

## React Хуки

Hooks — это функции из ядра React, которые позволяют функциональным компонентам хранить состояние, работать с жизненным
циклом и контекстом. (Правило: хуки вызываются только на верхнем уровне компонента (или в своих кастомных хуках), а не в
условиях/циклах.)

### useState(initialValue)

- Что: локальное состояние внутри компонента.
- Возвращает: [value, setValue].
- Как работает: при setValue React создаёт новое дерево UI и запускает процесс reconciliation.

### useEffect(fn, deps)

- Что: побочные эффекты (синхронизация с внешним миром: запросы, подписки, таймеры).
- Когда срабатывает: после commit-фазы (отрисовки в DOM).
- deps:
    - [] — один раз при монтировании.
    - [a, b] — при изменении зависимостей.
    - без deps — на каждом рендере.
- Очистка: возврат функции для анмаунта/повторного запуска:

### useLayoutEffect(fn, deps)

- Что: “синхронный” аналог useEffect.
- Когда: выполняется сразу после мутаций DOM, но до того, как браузер “покажет” изменения пользователю.
- Используется для: измерения DOM (offsetWidth, getBoundingClientRect), принудительной прокрутки, синхронных стилей.
- Важно: может блокировать отрисовку ⇒ применять только там, где нужен точный контроль.

### useRef(initialValue)

- Что: объект { current }, который React не отслеживает и не вызывает перерендер при изменении.
- Используется для:
    - доступ к DOM-элементу: <div ref={myRef}>.
    - хранение мутабельного значения между рендерами (например, id таймера).

### useMemo(factory, deps)

- Что: мемоизация результата “тяжёлого” вычисления.
- Как работает: React кэширует результат, пересчитает только если deps изменились.

### useCallback(fn, deps)

- Что: мемоизация функции (сохраняется ссылка).
- Когда нужно: чтобы не передавать “новую” функцию в дочерние компоненты на каждом рендере.

### useContext(Context)

- Что: доступ к значению контекста без проп-дриллинга.
- Как работает: если значение контекста изменилось, компонент-потребитель перерисовывается.

----

# Тема для разбора

- props (children, ...props)
- крутилка при fetch загрузке const loading, useLoading = useState() -- обычно выводится в отдельный кастомный хук и
  каждый fetch оборачивать
- обмен данными между компонентами -- всегда сверху вниз, но если надо снизу вверх - то callback в пропс фунцию передать
- условная отрисовка (тернарный оператор)
- способы взаимодействия в jsx со стилями -- все варианты
- Архитектура и жизненный цикл: Fiber-дерево, фазы render/commit, планировщик, batching, приоритеты.
- Рендереры и роли: react-dom (клиент/SSR/гидратация/стриминг), react-native (Yoga/бридж), другие (CLI/WebGL),
  react-reconciler.
- JSX под капотом: jsx/jsxs, элементы, key, фрагменты.
- “Работа с DOM вручную” vs React: декларативность против императивных манипуляций, где выигрываем по надежности и
  стоимости изменений.
- SPA/SSR/CSR/гидратация: что такое SPA на React, когда нужен серверный рендеринг и как он сочетается с клиентом.
- Виртуальное представление UI и согласование: зачем внутреннее дерево, как находится минимальный патч, когда
  “виртуальный DOM” полезная метафора, а когда нет.
- Экосистема и сборка: Node.js как среда разработки, Vite/Webpack, транспиляция JSX/TS, dev-серверы, HMR.
- react router dom
- роутинг, редирект, useHistory, useParams
- приватные и публичные маршруты
- https://youtu.be/GNrdg3PzpJQ?t=9490
- https://youtu.be/GNrdg3PzpJQ?t=10031
- https://youtu.be/GNrdg3PzpJQ?t=6571
- https://youtu.be/GNrdg3PzpJQ?t=6385
- Важные нюансы (не отдельные “стадии”, но влияет на поведение)
    - Гидратация (SSR) — частный случай монтирования: React “привязывается” к уже готовому HTML.
    - Concurrent/Transitions/Suspense — это про планирование: render может прерываться/повторяться до коммита.
      Пользователь видит изменения только после commit+paint; это не новая стадия.
    - StrictMode (dev) — намеренно удваивает некоторые вызовы (render/cleanup/run эффектов) для поиска сайд-эффектов. В
      проде один раз.
    - key меняется → ремонтирование (unmount + mount). Перенос узла без смены key — обычное обновление с мутацией
      позиции.

























