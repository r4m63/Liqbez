# React

## Что такое React

- **Библиотека для описания UI на JS**: ты описываешь что должно быть на экране для текущего состояния, а как применить
  изменения решает React.
- **Декларативность + Компонентый подход**: UI собирается из мелких переиспользуемых компонентов.
- Однонаправленные данные: props вниз, события (коллбеки) вверх; локальный state и при необходимости - контекст.
- **JSX синтаксис** -- это сахар над вызовами создания элементов (можно писать и без JSX).
- **Среда-агностичность**: ядро react не знает про DOM/платформу; отрисовку выполняет рендерер (React-DOM -- web,
  React-Native -- iOS/Android, CLI и т.д.). Идея: React Core описывает дерево UI и жизненный цикл, а конкретный рендерер
  знает как применить изменения в своей среде.
- React - не зависим от бразуера, React dom - отвечает за отрисовку в браузере.
- Предсказуемые обновления: изменение состояния -- React пересчитывает дерево UI и вносит минимальные правки в целевую
  среду.
- Не фреймворк: маршрутизация, глобальное состояние, данные, сборка — по выбору разработчика; React решает именно слой
  UI.
- React предоставляет разработку SPA приложений (html мы не пишем, мы пишем js, изначально происходит загрузка всего js
  всего сайта, и js на клиенте меняет html и приложение работает потом на клиенте быстрее) (без библиотеки - часто надо
  взаимодействовать с DOM деревом, получить элемент по классу по ид, добавить слушатели, удалить добавить и надо думать
  больше о том что куда добавить и что где добавить -- больше ошибки и больше времени, + все операции над DOM деревом
  ресурсоемки реакт сам следит за управлением дом деревом)

## React под капотом

### 1) Архитектура: ядро + рендерер (host)

- **Что это:** ядро `react` считает *что показать*, а рендерер (`react-dom`, `react-native` и т.п.) знает *как это
  нарисовать* в конкретной среде (DOM, iOS/Android, канвас, CLI).
- **Зачем:** одно “мозговое” ядро можно использовать в разных средах без переписывания логики.
- **Как работает:** вы пишете компоненты (JSX). Ядро строит описание UI; рендерер превращает его в реальные узлы (
  создать/удалить/обновить).
- **Важно:** код компонента может зависеть от среды (`window`, `document` в вебе). Держите такие вызовы изолированными.

---

### 2) Fiber: внутреннее дерево и двойная буферизация

- **Что это:** служебные узлы (Fiber) — по одному на каждый элемент интерфейса. Две версии дерева: **current** (экран) и
  **workInProgress** (новый расчёт).
- **Зачем:** можно считать обновления по частям, прерывать и безопасно продолжать, а на экране менять **атомарно**.
- **Как работает:** рендер пишет изменения в `workInProgress`; при коммите указатели меняются местами (swap) → новый
  экран.
- **Важно:** Fiber — не DOM и не “виртуальный DOM” прошлых лет; это структура управления работой.

---

### 3) Reconciler (согласователь) и дифф детей

- **Что это:** сравнение *старого* и *нового* описания UI, особенно списков.
- **Зачем:** чтобы менять только нужные части, а не “перерисовывать всё”.
- **Как работает:** сопоставление по **типу** и **`key`**. “Тип и `key` те же” → обновить; иначе → удалить/смонтировать
  заново.
- **Важно:** `key` должен быть стабильным `id` из данных, **не индекс массива**.

---

### 4) Двухфазная модель: Render → Commit

- **Что это:** строгий порядок двух фаз одного обновления.
- **Зачем:** отделить “чистые вычисления” от побочных действий/мутаций.
- **Как работает:**
  RENDER (чистая фаза):
  вызвать компоненты → прочитать props/state/context → посчитать JSX → пометить изменения на Fiber
  COMMIT (применение):
  мутации DOM/хоста → ref → useLayoutEffect → (кадр браузера) → useEffect
-
    - **Важно:** пока нет коммита, пользователь ничего не видит. Коммит короткий и не прерывается.

---

### 5) Планирование: приоритеты (Lanes), батчинг, переходы

- **Что это:** “когда” выполнять обновления и “что важнее”.
- **Зачем:** чтобы интерфейс оставался **отзывчивым**: ввод важнее фоновых перестроек.
- **Как работает:** каждое обновление получает приоритет (lane). Длинные расчёты можно прервать и продолжить.
  `startTransition` помечает обновления как второстепенные. В React 18 действует **автоматический батчинг** (объединяет
  соседние `setState`).
- **Важно:** дискретные события (клик/ввод) обычно доводят цикл до коммита быстро; `flushSync` — редкий “ручной тормоз”.

---

### 6) Очереди обновлений состояния (`setState`)

- **Что это:** у каждого Fiber есть очередь апдейтов; `setState` добавляет запись.
- **Зачем:** последовательно применить все обновления и правильно рассчитать новое состояние.
- **Как работает:** при рендере берётся `baseState` и прогоняется через список апдейтов → получается итог. Если
  `Object.is(новое, старое)` — можно пропустить лишний рендер.
- **Важно:** для вычислений “от предыдущего” используйте функциональную форму: `setX(prev => next(prev))`.

---

### 7) Контекст и распространение (propagation)

- **Что это:** общий источник данных для ветки дерева (`<Provider value=…>` → `useContext`).
- **Зачем:** не прокидывать одни и те же пропсы через много уровней.
- **Как работает:** при изменении `value` **все потребители** ниже перерисуются.
- **Важно:** дробите контексты по доменам (тема, язык, настройки), чтобы ограничить область перерисовок.

---

### 8) События: делегирование и завершение обновлений

- **Что это:** единая система событий поверх разных браузеров.
- **Зачем:** меньше слушателей, одинаковое поведение.
- **Как работает:** обработчик навешан высоко (на корне); события всплывают; React нормализует объект события и вызывает
  ваш коллбек. Для кликов/ввода обновления чаще завершаются синхронно до конца тика.
- **Важно:** не мутируйте DOM напрямую в обработчиках — меняйте состояние; React сам применит патч.

---

### 9) Эффекты: `useLayoutEffect` и `useEffect`

- **Что это:** места для кода, который взаимодействует с внешним миром (DOM-измерения, фокус, подписки, таймеры, сеть).
- **Зачем:** разделить вычисления UI и побочные действия.
- **Как работает:**
- `useLayoutEffect` — **после мутаций, до кадра**: измерения/фокус/скролл без мерцаний (выполняется сразу).
- `useEffect` — **после кадра**: подписки/таймеры/запросы.
- Оба могут вернуть **очистку** (unsubscription/clear), которая выполнится перед новым запуском и при размонтировании.
- **Важно:** не запускайте “бесконечные” эффекты — следите за массивом зависимостей.

---

### 10) SSR, гидратация, стриминг, приоритетная гидратация

- **Что это:** серверная отрисовка HTML и “привязка” на клиенте.
- **Зачем:** быстрый первый контент (TTFB), SEO, меньше “пустого экрана”.
- **Как работает:** сервер отдаёт HTML (вплоть до потоковой выдачи по частям). На клиенте `hydrateRoot` сопоставляет
  ожидания с уже готовым HTML и подключает обработчики. Есть приоритетная/селективная гидратация важных зон.
- **Важно:** серверный и клиентский рендер до эффектов должны совпадать. Используйте `useId` для согласованных `id`;
  спорные места прикрывайте `suppressHydrationWarning`.

---

### 11) Suspense и ленивые куски (код и данные)

- **Что это:** рамка ожидания и механизм “я пока не готов”.
- **Зачем:** не блокировать весь UI из-за одной части; показывать fallback (скелетон) и дорендеривать по готовности.
- **Как работает:** компонент/загрузка “бросает promise”; ближайший `Suspense` показывает fallback; по готовности →
  дорендер. На сервере поддерживает потоковую выдачу.
- **Важно:** ставьте границы `Suspense` вокруг тяжёлых зон (маршруты, большие виджеты).

---

### 12) Server Components (RSC)

- **Что это:** компоненты, рендерящиеся на сервере и **не попадающие** в JS-бандл клиента.
- **Зачем:** меньше клиентского JS, доступ к серверным ресурсам без лишних API-прослоек.
- **Как работает:** сервер генерирует дерево и поток инструкций; клиент “вклеивает” интерактивные клиентские компоненты
  там, где нужно.
- **Важно:** RSC — про разделение ответственности: данные/разметка на сервере, интерактивность на клиенте.

---

### 13) Ссылки (`ref`): жизненный цикл и формы

- **Что это:** способ получить доступ к DOM-элементу или хранить мутабельное значение между рендерами.
- **Зачем:** фокус, измерения, императивные действия.
- **Как работает:** в коммите сначала снимается старый `ref`, потом ставится новый. `useRef` не триггерит рендер при
  изменении `.current`. Callback-ref вызывается с `null`, затем с узлом.
- **Важно:** не читайте `.current` в рендере как источник истины — он вне реактивной модели.

---

### 14) Error Boundaries (границы ошибок)

- **Что это:** “контейнер”, который перехватывает ошибки рендера/лейаут-эффектов внизу и показывает запасной UI.
- **Зачем:** ошибка одного виджета не должна “ронять” всю страницу.
- **Как работает:** класс с `componentDidCatch` или готовые обёртки. При ошибке размонтируется проблемное поддерево,
  выполняются очистки эффектов и `ref`.
- **Важно:** размещайте границы на уровнях страниц/крупных блоков.

---

### 15) Формы: контролируемые и неконтролируемые

- **Что это:** *кто владеет значением поля* — React или сам DOM.
- **Зачем:** предсказуемость и удобство.
- **Как работает:** контролируемые — `value/checked` берутся из state + `onChange`; неконтролируемые — `defaultValue`/
  `defaultChecked` + чтение через `ref`.
- **Важно:** не смешивайте режимы для одного поля; это даёт странные состояния.

---

### 16) Производительность и диагностика

- **Что это:** набор приёмов и инструментов для уменьшения лишних перерисовок.
- **Зачем:** быстрый и плавный UI.
- **Как работает:**
- `React.memo` — мемоизация по `props` на узлах-листах/ячейках.
- `useMemo` — для дорогих вычислений; `useCallback` — для стабильных обработчиков.
- `useDeferredValue`/`startTransition` — откладывать неглавные обновления.
- `<Profiler>` и DevTools — кто/почему перерисовался.
- **Важно:** оптимизируйте **точечно**, отталкиваясь от замеров.

---

### Виртуальное DOM-дерево в React — ликбез (простым, но детально)

> Цель: понять, **что такое “виртуальный DOM” в React**, **зачем он нужен**, **как устроен внутри**, и **что от него
ожидать**.

---

1) Что именно называется “виртуальным DOM” в React

- **Описание UI в памяти**: результат вызова ваших компонентов — это **дерево React-элементов** (обычные JS-объекты:
  `{ type, props, key, ... }`).
- **Рабочее представление**: на основе элементов React строит и ведёт **дерево Fiber** — “рабочую” структуру, где на
  каждом узле хранятся прошлые/новые `props`, `state`, ссылки на детей/родителей и **пометки, что нужно изменить**.
- В разговорной речи оба уровня часто называют “виртуальным DOM”:  
  **Элементы** — “что хотим видеть”, **Fiber** — “как рассчитать и применить”.

> Важно: виртуальный DOM — **метафора**. React **не** сравнивает строки HTML и **не** держит “копию реального DOM
> один-в-один”.

---

2) Зачем это нужно

- **Декларативность**: вы описываете *что* нужно показать, а не *как* шаг-за-шагом менять DOM.
- **Минимальные изменения**: сравнивая прошлое и новое описание, React вычисляет **маленький патч** для реального DOM.
- **Кросс-платформенность**: один и тот же расчёт UI можно применить к разным “хостам” (DOM, iOS/Android, канвас, CLI).
- **Планирование**: расчёт можно **прервать и продолжить** (благодаря Fiber), чтобы UI оставался отзывчивым.

---

3) Как это работает по шагам (рендер → коммит)

Вы вызвали setState / пришли новые props.

RENDER (чистая фаза):

React вызывает компонент как функцию.

Получает НОВОЕ дерево элементов.

На основе него обновляет/строит НОВОЕ дерево Fiber.

Сравнивает с ПРОШЛЫМ Fiber, помечая “что поменять”.
(DOM не трогается.)

COMMIT (применение):

По пометкам Fiber: создать/удалить/обновить реальные узлы (DOM).

Обновить ref.

Запустить useLayoutEffect (до кадра), затем браузер рисует кадр.

Запустить useEffect (после кадра).

yaml
Копировать
Редактировать

---

4) Из чего состоит “виртуальная” часть (упрощённо)

### React-элемент (иммутабельный “план”)

{ type: Button, key: "42", props: { size: "sm", children: "Save" } }

Создаётся каждый рендер (через JSX → jsx/jsxs).

Не меняется после создания.

Fiber-узел (рабочая запись)
txt
Копировать
Редактировать
Fiber {
type, key,
pendingProps, // новые props
memoizedProps, // прошлые props
memoizedState, // прошлый state
child, sibling, return, // связи
flags // какие мутации сделать на commit
}
Живёт между рендерами, хранит контекст для согласования и коммита.

5) Как React находит различия (дифф/согласование)
   Главное правило сопоставления детей:

Одинаковый type и одинаковый key → обновить существующий узел (сохранить идентичность).

Иначе → размонтировать старый и смонтировать новый.

Пример со списком (почему key важен)
jsx
Копировать
Редактировать
// ПЛОХО: key = индекс (ломаются перестановки)
items.map((user, i) => <Row key={i} user={user} />)

// ХОРОШО: стабильный id из данных
items.map(user => <Row key={user.id} user={user} />)
Со стабильными key React поймёт, что элементы просто поменялись местами, а не “исчезли/появились”, и сделает минимальные
DOM-операции.

6) “Виртуальный DOM” и производительность — честно
   Он не магически быстрее любых ручных DOM-операций.

Выигрыш на практике даёт комбинация:

минимальные патчи (дифф),

батчинг обновлений,

приоритеты/прерывание длинных расчётов (Fiber),

мемоизация (React.memo, useMemo, useCallback),

правильные key в списках.

Если рендер сверхтяжёлый (большие таблицы, частые пересчёты), оптимизируйте вычисления и структуру, а не “вините vDOM”.

7) Что виртуальный DOM не делает
   Не: сравнивает/патчит “внутренности” HTML-строк.

Не: гарантирует, что “всё быстрее”. Это слой корректности и удобства, а не автоматической оптимальности.

Не: запускает эффекты/таймеры в рендере — это делают useEffect/useLayoutEffect в коммите.

8) Типовые сценарии обновлений (и что делает vDOM)
   Новые props → перерасчёт дерева элементов → пометить отличия в Fiber → точечные DOM-изменения.

setState → то же самое; если новое значение “как старое” (Object.is), можно пропустить лишний рендер.

Контекст изменился → потребители перечитаны → патчи только там, где реально отличается UI.

Списки → по key определяется, что переместить, что обновить, что удалить/добавить.

9) Где ошибки бьют по виртуальному DOM (и как исправить)
   key = индекс → лишние размонтирования/монтирования, теряется фокус/анимации.
   ✔ Используйте стабильные id.

Тяжёлые вычисления в рендере → длинная чистая фаза, задержки.
✔ useMemo для дорогих расчётов; выносите в воркеры.

Каждый раз новые ссылки/объекты в props → перерисовки вниз по дереву.
✔ useCallback/useMemo, React.memo на листьях.

Мутация DOM руками → расхождение ожиданий React и реальности.
✔ Меняйте state/props, DOM тронет React.

10) Короткая шпаргалка “как думать о vDOM”
    Думайте деревьями: рендер — это пересчёт описания UI.

Ключи в списках: всегда стабильные key.

Минимизируйте работу: мемоизация и батчинг важнее “ручного DOM”.

Эффекты по месту: измерения — в useLayoutEffect, подписки — в useEffect.

Профилируйте: смотрите, кто и почему рендерится (React DevTools / Profiler).

11) Ментальная модель в трёх строках
    scss
    Копировать
    Редактировать
    JSX → (элементы) → Fiber считает отличия → (commit) → минимально правим DOM
    Элементы — иммутабельный план,

Fiber — рабочая тетрадь с пометками,

Commit — аккуратный ремонт реального интерфейса.

Мини-пример: что реально делается при изменении фильтра
jsx
Копировать
Редактировать
function List({ items, query }) {
const filtered = useMemo(
() => items.filter(x => x.name.includes(query)),
[items, query]
)
return (
<ul>
{filtered.map(item => <li key={item.id}>{item.name}</li>)}
</ul>
)
}
При изменении query:

новый рендер создаёт новые элементы li,

Fiber помечает, какие li остаются (по key), какие добавляются/удаляются,

в commit React точечно вставляет/удаляет нужные DOM-узлы — всё остальное не трогает.

## Можно включить следующие пункты:

- Portals — рендер узла в другой DOM-контейнер без потери контекста (модальные окна, тултипы).
- StrictMode (dev-только) — намеренные повторные вызовы рендера/очисток, чтобы находить побочные эффекты.
- Profiler/DevTools — измерение причин и стоимости перерисовок.
- SuspenseList — координация нескольких Suspense (упорядоченное “раскрытие” частей UI).
- useDeferredValue — откладывает “тяжёлое” значение (родственник startTransition, но для данных).
- useSyncExternalStore — правильная интеграция с внешними сторами/подписками без “рваных” обновлений.
- Event replay при гидратации — события, пришедшие до “оживления”, переигрываются после подключения обработчиков.
- Ресурсные helpers в React DOM (preload/preconnect/preinit; зависят от версии) — подсказки браузеру о ресурсах ещё до
  рендера.
- Карта классовых lifecycle ↔ хуки (для совместимости со старым кодом): componentDidMount → useEffect(...),
  getSnapshotBeforeUpdate → useLayoutEffect, и т.п.

## Жизненный цикл компонента (монтирование, обновление, размонтирование)

Компонент — это функция, которая на вход получает свойства props и может хранить состояние state. Функция возвращает
описание интерфейса (JSX).

React берет это описание и показывает его в среде отображения (в браузере — в DOM).

За время работы страницы с компонентом происходит три типа событий:

1. Монтирование — компонент появляется впервые.
2. Обновление — что-то изменилось (props, state, контекст) и интерфейс надо пересчитать.
3. Размонтирование — компонент убирают с экрана.

Каждый раз, когда что-то из этих событий происходит, внутри есть два этапа:

- Рендер (render)
  Задача: понять, что должно быть на экране. Здесь нельзя изменять реальный интерфейс (DOM), ставить таймеры,
  подписываться на события — это “побочные действия”. Их место — эффекты. Render может повторяться (например, из-за
  планировщика или в режиме Strict Mode в разработке). Пока нет коммита, пользователь ничего не видит.
    - Вызывает функцию компонента как обычную JS-функцию.
    - Читает данные: свойства (props), состояние (state через useState/useReducer), контекст (useContext).
    - Выполняет мемоизации: useMemo/useCallback — берёт из кэша или пересчитывает, если зависимости изменились.
    - Формирует описание интерфейса (JSX → внутренняя структура элементов).
    - Сравнивает новое описание с предыдущим и готовит список изменений (“патч”), который нужно применить к реальному
      интерфейсу.

- Коммит (commit) - Задача: применить подготовленные изменения к реальному интерфейсу. Коммит происходит реже, чем
  рендер: если рендер прервали/переиграли, а изменений ещё не применяли, пользователь этого не увидит. Коммит всегда
  делает минимальные необходимые изменения (не “перерисовка всего”).
    - Мутации интерфейса: создать/удалить/переместить DOM-узлы, обновить атрибуты, повесить обработчики событий,
      назначить ref.
    - useLayoutEffect: сначала очистка старых, потом запуск новых — сразу после мутаций, до того как браузер покажет
      кадр. Здесь можно измерять размеры, ставить фокус, прокручивать без “морганий”.
    - Отрисовка кадра браузером (пользователь видит изменения).
    - useEffect: сначала очистка старых, потом запуск новых — после кадра. Здесь подписки, таймеры, запросы,
      логирование.

### Монтирование (компонент появляется впервые)

1. Рендер
   React вызывает вашу функцию-компонент. Здесь:
    - читаются props и state (если вы их завели через useState),
    - вычисляются мемоизации (useMemo, useCallback) — либо берется кеш, либо пересчет,
    - читается контекст (useContext),
    - возвращается JSX — описание того, что должно быть на экране.
2. Коммит
   React:
    - создает реальные DOM-узлы и вставляет их на страницу,
    - присваивает refs (объекты ref.current начинают указывать на DOM-элементы),
    - запускает синхронные эффекты разметки — useLayoutEffect. Это код, который должен выполниться сразу после вставки
      DOM, но до показа кадра. Например: измерить размеры блока и прокрутить к нему.
    - браузер рисует кадр (пользователь видит обновление),
    - запускает пассивные эффекты — useEffect. Это код, который можно выполнить “спокойно”, уже после кадра. Например:
      подписаться на веб-сокет, запустить таймер, отправить метрику.

**Что важно помнить**

- В рендере — только вычисления и возврат JSX.
- В useLayoutEffect — работа, которая должна произойти до отрисовки кадра (измерения, фокус без “морганий”).
- В useEffect — подписки, таймеры, запросы: то, что не должно блокировать кадр.

### Обновление (что-то изменилось)

**Сценарии обновления:**

- Изменились props -- Родитель передал другие значения
- Изменился state компонента -- Через setState/dispatch
- Изменилось значение контекста -- Любой потребитель useContext(MyContext) перерендерится, если MyContext.Provider дал
  новое value
- Перерисовался родитель -- По умолчанию дочерние компоненты тоже вызываются (Render), даже если их props формально те
  же. Как уменьшать это: React.memo у дочернего компонента + стабильные ссылки через useCallback/useMemo
- Изменился ключ (key) элемента в списке -- Для React это другой элемент → старый размонтируется, новый смонтируется (а
  не просто перерендерится).
- Внешние подписки/хранилища -- Библиотеки (Redux useSelector, useSyncExternalStore) под капотом вызывают setState в
  ваших компонентах.
- Навигация/состояние маршрута -- Смена маршрута меняет дерево компонентов → нужные части дерева рендерятся заново.
- Strict Mode (только Dev) -- Удваивает некоторые вызовы Render/cleanup, чтобы обнаружить ошибки сайд-эффектов (в
  продакшене этого нет).

1. Рендер
   Компонент снова вызывается как функция:
    - читается новое состояние/новые свойства,
    - useMemo/useCallback либо отдают кеш, либо пересчитываются (если зависимости изменились),
    - возвращается новый JSX.

2. Коммит
   React:
    - находит минимальный набор изменений в реальном интерфейсе (вставить/удалить/изменить только то, что действительно
      поменялось),
    - очищает старые useLayoutEffect (выполняет функции-очистки, которые вы вернули из useLayoutEffect ранее),
    - применяет изменения к DOM, заново присваивает ref,
    - запускает новые useLayoutEffect,
    - браузер рисует кадр,
    - очищает старые useEffect (если зависимости у эффекта изменились),
    - запускает новые useEffect.

**Что важно помнить**

- Если в useEffect вы вернули функцию-очистку, она обязательно выполнится перед следующим запуском этого же эффекта (и
  при размонтировании).
- Частая ошибка: в useEffect без условий вы вызываете setState → это снова вызывает эффект → бесконечный цикл. Следите
  за массивом зависимостей второго аргумента.

### Размонтирование (компонент удаляют)

Размонтирование == компонент больше не находится в дереве интерфейса.

**Сценарии размонтирования:**

- Условный рендеринг перестал быть истинным (`{isOpen ? <Modal/> : null} // isOpen стал false → <Modal/> размонтирован`)
- Списки: элемент исчез из данных
- Смена ключа (key) у элемента
- Навигация/смена маршрута -- Переход на другую страницу убирает часть дерева → эти компоненты размонтированы.
- Error Boundary “поймал” ошибку в поддереве -- Ветвь с ошибкой размонтируется и заменяется запасным UI (fallback).
- Разворот/сворачивание через состояние -- Любое изменение состояния/контекста/пропсов, которое приводит к тому, что
  компонент больше не возвращается из JSX родителя.

**Что не является размонтированием:**

- Скрытие через CSS (`display: none, visibility: hidden`) — узел остаётся в дереве, это не unmount.
- Очистка содержимого компонента (например, `<div />` вместо `<div>…</div>`) — сам компонент остаётся смонтирован.

1. Коммит
    - удаляются DOM-узлы компонента,
    - вызываются очистки useLayoutEffect,
    - затем вызываются очистки useEffect,
    - ref.current перестает указывать на DOM-элементы (становится null, если это DOM-ref).

**Что важно помнить**

- Все подписки, таймеры, наблюдатели нужно снимать/останавливать в функциях-очистках, которые вы возвращаете из
  useEffect/useLayoutEffect. Тогда ресурсы не будут “утекать”.

## React Хуки

Hooks — это функции из ядра React, которые позволяют функциональным компонентам хранить состояние, работать с жизненным
циклом и контекстом. (Правило: хуки вызываются только на верхнем уровне компонента (или в своих кастомных хуках), а не в
условиях/циклах.)

### useState(initialValue)

- Что: локальное состояние внутри компонента.
- Возвращает: [value, setValue].
- Как работает: при setValue React создаёт новое дерево UI и запускает процесс reconciliation.

### useEffect(fn, deps)

- Что: побочные эффекты (синхронизация с внешним миром: запросы, подписки, таймеры).
- Когда срабатывает: после commit-фазы (отрисовки в DOM).
- deps:
    - [] — один раз при монтировании.
    - [a, b] — при изменении зависимостей.
    - без deps — на каждом рендере.
- Очистка: возврат функции для анмаунта/повторного запуска:

### useLayoutEffect(fn, deps)

- Что: “синхронный” аналог useEffect.
- Когда: выполняется сразу после мутаций DOM, но до того, как браузер “покажет” изменения пользователю.
- Используется для: измерения DOM (offsetWidth, getBoundingClientRect), принудительной прокрутки, синхронных стилей.
- Важно: может блокировать отрисовку ⇒ применять только там, где нужен точный контроль.

### useRef(initialValue)

- Что: объект { current }, который React не отслеживает и не вызывает перерендер при изменении.
- Используется для:
    - доступ к DOM-элементу: <div ref={myRef}>.
    - хранение мутабельного значения между рендерами (например, id таймера).

### useMemo(factory, deps)

- Что: мемоизация результата “тяжёлого” вычисления.
- Как работает: React кэширует результат, пересчитает только если deps изменились.

### useCallback(fn, deps)

- Что: мемоизация функции (сохраняется ссылка).
- Когда нужно: чтобы не передавать “новую” функцию в дочерние компоненты на каждом рендере.

### useContext(Context)

- Что: доступ к значению контекста без проп-дриллинга.
- Как работает: если значение контекста изменилось, компонент-потребитель перерисовывается.

----

# Тема для разбора

- подробно расписать в разделе ## React под капотом о каждом пункте как оно реализовано под капотом
- props (children, ...props)
- крутилка при fetch загрузке const loading, useLoading = useState() -- обычно выводится в отдельный кастомный хук и
  каждый fetch оборачивать
- обмен данными между компонентами -- всегда сверху вниз, но если надо снизу вверх - то callback в пропс фунцию передать
- условная отрисовка (тернарный оператор)
- способы взаимодействия в jsx со стилями -- все варианты
- Архитектура и жизненный цикл: Fiber-дерево, фазы render/commit, планировщик, batching, приоритеты.
- Рендереры и роли: react-dom (клиент/SSR/гидратация/стриминг), react-native (Yoga/бридж), другие (CLI/WebGL),
  react-reconciler.
- JSX под капотом: jsx/jsxs, элементы, key, фрагменты.
- “Работа с DOM вручную” vs React: декларативность против императивных манипуляций, где выигрываем по надежности и
  стоимости изменений.
- SPA/SSR/CSR/гидратация: что такое SPA на React, когда нужен серверный рендеринг и как он сочетается с клиентом.
- Виртуальное представление UI и согласование: зачем внутреннее дерево, как находится минимальный патч, когда
  “виртуальный DOM” полезная метафора, а когда нет.
- Экосистема и сборка: Node.js как среда разработки, Vite/Webpack, транспиляция JSX/TS, dev-серверы, HMR.
- react router dom
- роутинг, редирект, useHistory, useParams
- приватные и публичные маршруты
- https://youtu.be/GNrdg3PzpJQ?t=9490
- https://youtu.be/GNrdg3PzpJQ?t=10031
- https://youtu.be/GNrdg3PzpJQ?t=6571
- https://youtu.be/GNrdg3PzpJQ?t=6385
- Важные нюансы (не отдельные “стадии”, но влияет на поведение)
    - Гидратация (SSR) — частный случай монтирования: React “привязывается” к уже готовому HTML.
    - Concurrent/Transitions/Suspense — это про планирование: render может прерываться/повторяться до коммита.
      Пользователь видит изменения только после commit+paint; это не новая стадия.
    - StrictMode (dev) — намеренно удваивает некоторые вызовы (render/cleanup/run эффектов) для поиска сайд-эффектов. В
      проде один раз.
    - key меняется → ремонтирование (unmount + mount). Перенос узла без смены key — обычное обновление с мутацией
      позиции.

























