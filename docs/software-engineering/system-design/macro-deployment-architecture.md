# Deployment/Topology (Macro-Architecture): Архитектура приложения

-- добавить распределенные системы load balancer и тд

## Полный список архитектурных стилей (Macro-Architecture)

- **Микросервисы (Microservices)**
    - Почти де-факто стандарт для крупных распределённых приложений.
- **Слойный монолит (3-Tier)**
    - Всё ещё популярен в корпоративных системах, где DevOps-зрелость ниже.
- **Self-Contained Systems (SCS)**
    - Часто встречается в B2B-порталах и white-label платформах.
- **Backend-for-Frontend (BFF)**
    - Практика почти в любом проекте с несколькими типами клиентов (web/mobile).
- **Event-Driven Architecture (EDA) / CQRS + Event Sourcing**
    - Всё больше проектов строят через Kafka/Pulsar, особенно для streaming- и реактивных систем.
- **Serverless / FaaS**
    - Широко применяют для «glue-code», триггерных функций и микросервисов без забот об инфраструктуре.
- **Service Mesh (sidecar pattern)**
    - Становится обязательным слоем в любом крупном Kubernetes-кластере с сотнями сервисов.
- **Hybrid / Multi-Cloud / Edge**
    - Для глобальных SaaS-решений и low-latency сценариев (edge-compute) — всё чаще.
- **Монолит**
    - Чистый монолит без чёткого разделения слоёв и модульности сейчас почти не выбирают для новых проектов, разве что в
      очень простых MVP.
- **SOA (Service-Oriented Architecture)**
    - Раньше было очень популярно в корпоративном секторе, но тяжеловесный ESB → SPOF и сложности поддержки почти
      полностью вытеснено микросервисами и интеграционными шинами без единого центра
- **Actor-Model Cluster**
    - В узких сценариях (игры, телеком, IoT) — да, но в большинстве веб- и бизнес-систем «актеры» редко применяют.
- **Pipes & Filters / Data-Pipeline**
    - Используют внутри систем для обработки данных, но редко проектируют весь сервис по этому принципу.

## Монолит

- **Суть** — один исполняемый процесс/артефакт, общая база данных.
- **Плюсы**
    - Простая локальная отладка и развертывание.
    - Сквозные транзакции без распределённой согласованности.
    - Минимум DevOps-инфраструктуры.
- **Минусы**
    - Масштабируется только «целиком» (память/CPU → вертикальный рост).
    - Слабая изоляция доменов → «spaghetti code» при росте.
    - Релиз любого изменения = релиз всего приложения.
- **Типичные технологии**  
  Spring Boot ⟶ JAR/WAR, Laravel/PHP-FPM, Ruby on Rails, Django; единственная БД (PostgreSQL, MySQL).
- **Когда выбрать**  
  MVP/PoC, команда ≤ 5-7 человек, чёткая долгосрочная граница продукта.

## Слойный монолит (3-Tier)

- **Суть** — логические слои UI / бизнес-логика / СУБД разнесены по разным процессам или контейнерам, но релиз и
  жизненный цикл едины.
- **Плюсы**
    - Чёткая ответственность слоёв, легче менять UI или БД изолированно.
    - Хорошо поддерживается большинством фреймворков.
- **Минусы**
    - Всё ещё «монолит» в смысле масштабирования и выпуска.
    - Большие накладные расходы (сеть между слоями).
- **Типичные технологии**  
  Nginx → Java EE/WildFly → Oracle DB; React → .NET Web API → SQL Server.
- **Когда выбрать**  
  Корпоративные LOB-системы, где чётко разделены UI-команда и сервер-команда.

## SOA (Service-Oriented Architecture)

- **Суть** — крупные бизнес-сервисы (coarse-grained) обмениваются сообщениями через ESB/шину.
- **Плюсы**
    - Службы могут быть написаны на разных технологиях.
    - Централизованные кросс-каттинги (логирование, безопасность) в шине.
- **Минусы**
    - ESB = потенциальный SPOF, сложная настройка.
    - Часто приводит к «distributed monolith» из-за плотных зависимостей.
- **Типичные технологии**  
  MuleSoft, Apache ServiceMix, WSO2, IBM Integration Bus.
- **Когда выбрать**  
  Регульно-обязательные интеграции (банк, телеком), наследие ESB, гетерогенная среда.

## Микросервисы

- **Суть** — малые автономные сервисы, каждый с собственной БД/хранилищем, общаются по сети (HTTP/gRPC, message-bus).
- **Плюсы**
    - Независимые релизы и масштабирование.
    - Polyglot-подход к технологиям и БД.
    - Чёткая граница областей ответственности.
- **Минусы**
    - Сетевые задержки и сложность трассировки.
    - Распределённая консистентность → саги, outbox, идемпотентность.
    - Требуют зрелой DevOps-культуры.
- **Типичные технологии**  
  Docker + Kubernetes, gRPC/REST, Apache Kafka/NATS, Istio/Linkerd, Jaeger/Tempo.
- **Когда выбрать**  
  Быстрорастущие продукты, многокомандная разработка (≥ 10 команд), высокая нагрузка.

## Self-Contained Systems (SCS)

- **Суть** — каждому домену — полностью автономное «мини-приложение» (UI + API + данные) в одном артефакте.
- **Плюсы**
    - Независимый деплой UI и backend-логики вместе.
    - Слабая связанность между системами.
- **Минусы**
    - Дублирование кода/инфраструктуры между SCS.
    - Труднее поддерживать единый UX-стиль.
- **Типичные технологии**  
  Next.js + Node.js + MongoDB; Java Modulith; single-SPA фреймворки.
- **Когда выбрать**  
  B2B-порталы, white-label решения, multi-tenant-продукты.

## Backend-for-Frontend (BFF)

- **Суть** — отдельные шлюзы под каждый клиент (веб, мобильный, IoT), адаптируют API, аггрегируют данные.
- **Плюсы**
    - Оптимизированные ответы для разных клиентов.
    - Быстрый выпуск фич без изменения микросервисов.
- **Минусы**
    - Дублирование бизнес-логики в разных BFF.
    - Ещё один уровень поддержки и мониторинга.
- **Типичные технологии**  
  GraphQL Apollo Server, Spring Cloud Gateway, FastAPI, AWS AppSync.
- **Когда выбрать**  
  Множество клиентских приложений с разными требованиями к данным и интерфейсу.

## Event-Driven / EDA

- **Суть** — асинхронная шина/стрим как основа коммуникации; сервисы реагируют на события (pub/sub, CQRS + Event
  Sourcing).
- **Плюсы**
    - Слабая связанность сервисов.
    - Естественная поддержка audit-log и replay-механизмов.
- **Минусы**
    - Сложная отладка и контроль порядка событий.
    - Трудно гарантировать «точное одно» исполнение.
- **Типичные технологии**  
  Apache Kafka/Pulsar, AWS Kinesis, Debezium, Axon Framework, EventStoreDB.
- **Когда выбрать**  
  Высокая пропускная способность, требования к реагированию в реальном времени, сложная аналитика на событиях.

## Serverless / FaaS

- **Суть** — код развёртывается как функции-обработчики событий; провайдер управляет инфраструктурой и масштабированием.
- **Плюсы**
    - Нет управления серверами или кластерами.
    - Авто-масштабирование и оплата «за вызов».
- **Минусы**
    - Холодный старт, ограничения времени выполнения и ресурсов.
    - Vendor lock-in и сложности локального тестирования.
- **Типичные технологии**  
  AWS Lambda + API Gateway, Azure Functions, Google Cloud Functions, OpenFaaS.
- **Когда выбрать**  
  Непредсказуемая или нерегулярная нагрузка, интеграционные задачи, cron-запуски.

## Actor-Model Cluster

- **Суть** — множество актёров (активных объектов) с изолированным состоянием, взаимодействие по сообщениям.
- **Плюсы**
    - Природная модель параллелизма без блокировок.
    - Лёгкое управление состоянием каждого актора.
- **Минусы**
    - Требует специфического рантайма и паттернов.
    - Интеграция с обычными HTTP-сервисами может быть сложной.
- **Типичные технологии**  
  Akka Cluster, Erlang/OTP, Microsoft Orleans, Dapr Actors.
- **Когда выбрать**  
  Онлайн-игры, телеком-сигналинг, IoT-управление большим числом устройств.

## Pipes & Filters / Data-Pipeline

- **Суть** — данные проходят через цепочку независимых фильтров/трансформеров (batch или stream).
- **Плюсы**
    - Простая добавляемость и перестановка этапов обработки.
    - Высокая конвейерная производительность.
- **Минусы**
    - Идемпотентность и управление ошибками на каждом этапе сложны.
    - Необходим детальный мониторинг каждого шага.
- **Типичные технологии**  
  Apache Beam, Flink, Airflow + Spark, Kafka Streams, AWS Glue.
- **Когда выбрать**  
  ETL/ELT, real-time аналитику, подготовку данных для ML.

## Service Mesh

- **Суть** — сетевая логика вынесена в sidecar-прокси; mesh управляет маршрутизацией, безопасностью и наблюдаемостью.
- **Плюсы**
    - Единая политика безопасности и маршрутизации.
    - Встроенный circuit-breaking, retries, A/B-тестирование без изменений кода.
- **Минусы**
    - Дополнительные ресурсы на sidecar, сложная initial setup.
    - Требует зрелой операторской команды.
- **Типичные технологии**  
  Istio, Linkerd, Consul Connect, Kuma, AWS App Mesh.
- **Когда выбрать**  
  Множество микросервисов, жёсткие SLO/SLA, zero-trust требования.

## Hybrid / Multi-Cloud / Edge

- **Суть** — нагрузки распределены между несколькими облаками, on-prem и/или edge-устройствами; единая модель
  управления.
- **Плюсы**
    - Снижение vendor lock-in и гео-близость к клиентам.
    - Высокая доступность при сбоях одного провайдера.
- **Минусы**
    - Сложное сетевое планирование и latency-проблемы.
    - Разные биллинговые и секрет-менеджмент консоли.
- **Типичные технологии**  
  Kubernetes Federation, Crossplane, HashiCorp Consul + Vault + Nomad, AWS Outposts, Azure Arc, Cloudflare Workers.
- **Когда выбрать**  
  Глобальные SaaS-решения, требования GDPR/on-prem, IoT/AR-low latency сценарии.

# Как выбрать архитектуру под проект

1. **Масштаб и сложность**

- **Микросервисы**: высокие нагрузки (TPS > 10⁴), сотни разработчиков
- **Монолит / 3-Tier**: MVP, небольшие команды (≤ 7 человек), простой домен
- **Serverless**: нерегулярные пиковые нагрузки, “glue-code” сценарии

2. **Наличие DevOps-культуры**

- Зрелая CI/CD, Infrastructure-as-Code, контейнеризация → микросервисы, service mesh, serverless
- Минимальная DevOps-поддержка → монолит, 3-Tier

3. **Границы ответственности и независимый деплой**

- Необходимость изолированных релизов и межкомандных границ → микросервисы, SCS, BFF
- Централизованное управление фичами и единый деплой → монолит, SOA

4. **Отказоустойчивость и задержка**

- Геораспределённые active-active сценарии → microservices + service mesh, hybrid/multi-cloud
- Критически низкая латентность → edge, actor-model, pipes & filters для стриминга

5. **Сложность данных и консистентность**

- Жёсткие ACID-требования → монолит, 3-Tier
- Eventual consistency, CQRS → EDA, микросервисы с outbox-pattern

6. **Cost-management и биллинг**

- Оплата “за вызов” vs “за время работы” → serverless vs контейнеры/VMs
- Оптимизация затрат через мультиоблако → hybrid/multi-cloud

7. **Экосистема и экспертиза команды**

- Kubernetes, gRPC, Kafka → микросервисы
- Java EE, ESB → SOA
- SPA/Frontend-ориентированная команда → SCS, BFF

8. **Инструменты поддержки**

- **Микросервисы**: Docker + Kubernetes, Istio/Linkerd, Kafka/NATS, Jaeger/Tempo
- **Service Mesh**: Istio, Linkerd, AWS App Mesh
- **Serverless**: AWS Lambda, Azure Functions, Google Cloud Functions
- **Монолит/3-Tier**: Spring Boot, Rails, Django + Nginx, PostgreSQL

9. **Фреймворк принятия решения**

- Сформировать минимальные требования (RPS, SLA, команды)
- Оценить DevOps-готовность
- Нарисовать потенциальные топологии (C4 Deployment Diagrams)
- Пройти checklist плюсов/минусов для 2–3 кандидатов
- Провести spike-proof of concept (микросервис, монолит, serverless)
- Финализировать решение с учётом TCO и roadmap  
