# HTTP

## Способы передачи данных c клиента на сервер:

- Query (Get-параметры)
    ```
    /book?author=name
    ```
- Body запроса (Json, XML)
    ```
    {"author"="name", "title"="book1"}
    ```
- Заголовки
- Cookies

## Способы передачи данных c сервера на клиент:

- Body ответа (Json, XML)
- Status Code
- Заголовки
- Cookies

## HTTP Body Types

| Тип                                                           | Где и зачем применяется                                                                                                            |
|---------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| **`application/json`**                                        | Основной формат обмена данными в REST-, GraphQL- и большинстве webhook-API. Читается нативно во фронтенд-фреймворках и на сервере. |
| **`text/html`**                                               | “Язык” веб-страниц. Каждый браузер по умолчанию ожидает HTML при переходе по URL.                                                  |
| **`application/x-www-form-urlencoded`**                       | Данные простых HTML-форм (`key=value&…`) — поиск, логин, фильтры. Разбирается любым бэкенд-фреймворком без доп. настроек.          |
| **`multipart/form-data`**                                     | Загрузка файлов через `<form>` (аватары, документы). Содержит текстовые поля и двоичные части в одном запросе.                     |
| **`text/css`**                                                | Таблицы стилей. Без него не будет оформления страниц; кешируется агрессивно, поэтому критичен для производительности.              |
| **`application/javascript`** *(или устар. `text/javascript`)* | Скрипты клиентской логики: React, Vue, аналитика. На него завязаны SPA и интерактивность.                                          |
| **`image/png`, `image/jpeg`, `image/webp`**                   | Основные форматы растровых картинок (лого, фото, иконки). Их суммарный вес — львиная доля трафика сайтов.                          |
| **`application/octet-stream`**                                | “Скачать файл как есть”. Универсально для любого бинарного контента, когда точный тип не важен или неизвестен.                     |
| **`application/xml`**                                         | SOAP-сервисы, RSS/Atom-ленты, конфигурационные файлы. Всё ещё нужен во множестве корпоративных систем.                             |
| **`application/pdf`**                                         | Электронные счета, отчёты, билеты. Браузеры умеют показывать inline, а серверы часто генерируют его на лету.                       |

## Коды ответов http

| Код | Фраза                 | Для чего нужен                                        |
|-----|-----------------------|-------------------------------------------------------|
| 100 | Continue              | Клиент может продолжать тело запроса                  |
| 101 | Switching Protocols   | Сервер переходит на другой протокол (WebSocket и др.) |
| 102 | Processing *(WebDAV)* | Долгая операция, ещё выполняется                      |
| 103 | Early Hints           | Заголовки-подсказки (`Link`) до окончательного ответа |

| Код | Фраза                         | Назначение                                 |
|-----|-------------------------------|--------------------------------------------|
| 200 | OK                            | Запрос успешен                             |
| 201 | Created                       | Создан новый ресурс                        |
| 202 | Accepted                      | Принят в обработку, результата пока нет    |
| 203 | Non-Authoritative Information | Прокси изменил исходный ответ              |
| 204 | No Content                    | Тело отсутствует, но всё ОК                |
| 205 | Reset Content                 | Очистить формы на клиенте                  |
| 206 | Partial Content               | Фрагмент (Range)                           |
| 207 | Multi-Status *(WebDAV)*       | Множественные результаты по коллекции      |
| 208 | Already Reported *(WebDAV)*   | Узел уже был отражён ранее                 |
| 226 | IM Used                       | Ответ содержит delta-обновление (RFC 3229) |

| Код | Фраза              | Что делает                                           |
|-----|--------------------|------------------------------------------------------|
| 300 | Multiple Choices   | Несколько вариантов                                  |
| 301 | Moved Permanently  | Постоянный редирект                                  |
| 302 | Found              | Временный редирект (исторически «Moved Temporarily») |
| 303 | See Other          | Перейти по другому URI (POST→GET)                    |
| 304 | Not Modified       | Кэш актуален (`ETag`/`Last-Modified`)                |
| 305 | Use Proxy          | Депрецировано, требовался прокси                     |
| 306 | (Unused)           | Зарезервировано                                      |
| 307 | Temporary Redirect | Временный, сохраняет метод                           |
| 308 | Permanent Redirect | Постоянный, сохраняет метод                          |

| Код | Фраза                                     | Когда возникает                              |
|-----|-------------------------------------------|----------------------------------------------|
| 400 | Bad Request                               | Синтаксическая ошибка                        |
| 401 | Unauthorized                              | Требуется аутентификация                     |
| 402 | Payment Required                          | Зарезервирован (часто для квот/платежей)     |
| 403 | Forbidden                                 | Доступ запрещён                              |
| 404 | Not Found                                 | Ресурс не найден                             |
| 405 | Method Not Allowed                        | Метод не поддерживается                      |
| 406 | Not Acceptable                            | Нет представления, подходящего под `Accept`  |
| 407 | Proxy Authentication Required             | Нужна auth к прокси                          |
| 408 | Request Timeout                           | Клиент слишком медленный / idle              |
| 409 | Conflict                                  | Конфликт состояния ресурса                   |
| 410 | Gone                                      | Ресурс удалён без возврата                   |
| 411 | Length Required                           | Нет `Content-Length`, а он обязателен        |
| 412 | Precondition Failed                       | Нарушены `If-*` условия                      |
| 413 | Payload Too Large                         | Тело превышает лимит                         |
| 414 | URI Too Long                              | URL непропорционально велик                  |
| 415 | Unsupported Media Type                    | Неподдерживаемый `Content-Type`              |
| 416 | Range Not Satisfiable                     | Диапазон вне ресурса                         |
| 417 | Expectation Failed                        | `Expect: 100-continue` не выполнено          |
| 418 | I'm a teapot Δ                            | Пасхалка «RFC 2324»                          |
| 421 | Misdirected Request                       | Соединение к другому хосту                   |
| 422 | Unprocessable Content *(WebDAV/RFC 9110)* | Семантически неверный JSON/XML               |
| 423 | Locked *(WebDAV)*                         | Ресурс заблокирован                          |
| 424 | Failed Dependency *(WebDAV)*              | Предыдущее действие провалилось              |
| 425 | Too Early                                 | Повторная отправка небезопасна (HTTP Replay) |
| 426 | Upgrade Required                          | Перейдите на другой протокол                 |
| 428 | Precondition Required                     | Требуются `If-Match`/`If-Unmodified-Since`   |
| 429 | Too Many Requests                         | Лимит запросов (rate-limit)                  |
| 431 | Request Header Fields Too Large           | Слишком большие заголовки                    |
| 451 | Unavailable For Legal Reasons             | Блокировка по закону (DMCA, суд)             |

| Код | Фраза                           | Когда применяется                           |
|-----|---------------------------------|---------------------------------------------|
| 500 | Internal Server Error           | Общее «что-то сломалось»                    |
| 501 | Not Implemented                 | Метод не поддержан                          |
| 502 | Bad Gateway                     | Промежуточный сервер получил неверный ответ |
| 503 | Service Unavailable             | Сервис временно недоступен (обслуживание)   |
| 504 | Gateway Timeout                 | Апстрим не ответил вовремя                  |
| 505 | HTTP Version Not Supported      | Версия протокола не поддерживается          |
| 506 | Variant Also Negotiates         | Ошибка content-negotiation                  |
| 507 | Insufficient Storage *(WebDAV)* | Недостаточно места                          |
| 508 | Loop Detected *(WebDAV)*        | В WebDAV-дереве рекурсия                    |
| 510 | Not Extended                    | Требуются доп. расширения метода            |
| 511 | Network Authentication Required | Портал авторизации (Wi-Fi captive)          |

## URI vs URL

| Аспект            | URI                                                                        | URL                                                                            |
|-------------------|----------------------------------------------------------------------------|--------------------------------------------------------------------------------|
| **Цель**          | Однозначно идентифицировать ресурс в абстрактном пространстве имён.        | Указать сетевой механизм доступа + расположение ресурса.                       |
| **Схема**         | Любая, в т. ч. нестандартная (`urn:`, `tel:`, `data:`).                    | Сетевые протоколы (`http:`, `https:`, `ftp:`, `ws:` …).                        |
| **Локатор?**      | Может, но не обязан. Пример без локации — URN.                             | Всегда содержит информацию «где» и «как».                                      |
| **Компоненты**    | `scheme:[//authority]path[?query][#fragment]` — но authority необязателен. | Обязательны `scheme://authority/path` (query и fragment опциональны).          |
| **Примеры**       | `urn:isbn:9780306406157` (книга) <br>`tel:+49-30-1234567` (номер телефона) | `ftp://ftp.kernel.org/pub/linux/README` <br>`https://github.com/user/repo.git` |
| **Использование** | XML-Namespaces, RDF, MIME-types, SIP-идентификаторы.                       | Ссылки в HTML, API-эндпоинты, загрузка файлов.                                 |
| **Стандарт**      | RFC 3986 (общие правила), RFC 8141 (URN).                                  | Тот же RFC 3986 + уточнения в отдельных RFC для схем (`http`, `ftp` и т. д.).  |

## HTTP Кэширование (заголовки ответа - Cache-Control, Expires, ETag)

# Архитектуры клиент-серверного взаимодействия веб приложений

## REST API

**REST API** - это архитектурный стиль клиент-серверного взаимодействия, который определяет, по каким правилам
приложения должны обмениваться данными между собой.

- Stateless. Сервер не хранит состояние клиента. Каждый запрос содержит всю необходимую информацию.
- Все данные представлены в виде ресурсов endpoint (/users, /products).
- Использование стандартных HTTP-методов (GET, POST, PUT, DELETE, etc).
- Ответы сервера могут быть кэшированы для повышения производительности.
- Слоистая система. Клиент не знает, взаимодействует ли он напрямую с сервером или через прокси.
- Формат данных json (xml устаревшее)

### Структура REST API endpoints ресурсов

Основные правила:

1. Использовать существительные (не глаголы)

   Плохо: `/getUsers`, `/createOrder`, `/deleteProduct`

   Хорошо: GET `/users`, POST `/orders`, DELETE `/products/{id}`

2. Называть ресурсы во множественном числе (Единообразие и явное указание на коллекцию)

   GET `/users` (все пользователи)

   GET `/users/1` (конкретный пользователь)

3. Использовать нижний регистр и дефисы (kebab-case)

   Плохо: `/UserOrders`, `/productCategories`

   Хорошо: `/user-orders`, `/product-categories`

4. Избегать пробелов и спецсимволов

   Вместо пробелов использовать `-` или `_`:
   GET `/product-categories` (лучше, чем `/product%20categories`)

Иерархия ресурсов:

1. Вложенность для связанных сущностей. Если ресурс принадлежит другому ресурсу, использовать иерархию:

   `/users/{userId}/orders` - Заказы пользователя

   `/users/{userId}/orders/{orderId}` - Конкретный заказ

2. Глубина вложенности ≤ 2–3 уровней

   Плохо: `/users/1/orders/5/products/3/reviews`

   Лучше: `/reviews?productId=3&userId=1` (с фильтрацией)

3. Для фильтрации, сортировки, пагинации - использовать query-параметры
   GET `/users?role=admin&status=active`
   GET `/products?sort=-price,created_at` - `-` = DESC
   GET `/articles?page=2&limit=10`

4. Версионирование API

   `/api/v1/users`

   `/api/v2/users`

### Документирование

Swagger - документация

### Тестирование

## GraphQL

GraphQL — это спецификация языка запросов и система выполнения, которая может работать поверх разных транспортных
протоколов (HTTP, WebSocket)

- GraphQL сам по себе stateless (как и REST), но может использоваться в stateful-сценариях:
    - Stateless-часть (HTTP): Обычные запросы (Queries) и мутации (Mutations) работают через HTTP (как REST).
    - Stateful-часть (WebSocket): Подписки (Subscriptions) требуют постоянного соединения (WebSocket), которое
      поддерживает состояние.
- Один URL (/graphql)
- Клиент каждый раз определяет что получать (получает только запрошенные поля)

### Работа GraphQL под капотом

Клиент:

- Отправляет GraphQL-запрос (Query/Mutation) через HTTP POST:

```
POST /graphql HTTP/1.1
Content-Type: application/json

{
  "query": "query { user(id: 1) { name email } }"
}
```

Сервер:

- Парсит запрос.
- Валидирует его против схемы.
- Выполняет через резолверы (функции для получения данных).
- Возвращает JSON-ответ:

```
{ "data": { "user": { "name": "Alice", "email": "example@example.com" } } }
```

Подписки (WebSocket):

- Для Subscriptions используется WebSocket (протокол graphql-ws)
- Сервер поддерживает состояние соединения и сам отправляет данные при событиях.

```
// Клиент подключается к WebSocket и отправляет:
{
  "type": "subscribe",
  "query": "subscription { newMessage { text } }"
}
```

**Как GraphQL делает выборку данных?**

Механизм резолверов (Resolvers): Каждое поле в GraphQL-запросе обрабатывается резолвером — функцией, которая знает, где
взять данные.

```
# Схема
type Query {
  user(id: ID!): User
}

type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]!
}

// Резолверы
const resolvers = {
Query: {
user: (parent, args, context) => {
return db.users.find(user => user.id === args.id); // Данные из БД
}
},
User: {
posts: (user) => {
return db.posts.filter(post => post.authorId === user.id); // Связанные данные
}
}
        };
```

**Процесс выполнения запроса:**

- Парсинг: Сервер разбирает GraphQL-запрос в AST (Abstract Syntax Tree).
- Валидация: Проверяет, что запрос соответствует схеме.
- Исполнение:
    - Для каждого поля запускается соответствующий резолвер.
    - Резолверы могут получать данные из:
    - БД (SQL, MongoDB).
    - Других API (REST, gRPC).
    - Кэша (Redis).
- Сборка ответа: Данные объединяются в JSON-структуру, запрошенную клиентом.

### Принцип работы запросов

**Гибкие запросы данных (Queries)**

- Клиент точно указывает, какие данные ему нужны.
- Можно запрашивать связанные данные за один запрос (например, пользователя и его посты).
- Избегает проблем over-fetching (получение лишних данных) и under-fetching (недостаточность данных).
    ```
    query {
      user(id: "1") {
        name
        email
        posts {
          title
          comments {
            text
          }
        }
      }
    }
    ```

**Изменение данных (Mutations)**

- Аналог POST/PUT/PATCH/DELETE в REST.
- Позволяет изменять данные на сервере и сразу получать обновленные поля в ответе.
  ```
  mutation {
    createPost(title: "New Post", content: "Hello!") {
      id
      title
    }
  }
  ```

**Реал-тайм обновления (Subscriptions)**

- Сервер может отправлять данные клиенту без запроса (например, уведомления, чаты).
- Работает через WebSocket (graphql-ws или subscriptions-transport-ws).
  ```
  subscription {
    newMessage(roomId: "123") {
      id
      text
      sender {
        name
      }
    }
  }
  ```

**Интроспекция API**

- Клиент может автоматически получать схему API (типы, поля, документацию).
- Используется для генерации документации (например, GraphiQL).
  ```
  query {
    __schema {
      types {
        name
        fields {
          name
          type {
            name
          }
        }
      }
    }
  }
  ```

### Инициация запроса с сервера

Сервер может инициировать запрос к клиенту, но только через подписки (Subscriptions).

- Клиент подключается к серверу через WebSocket.
- Сервер пассивно ожидает событий (например, новое сообщение в чате).
- Когда событие происходит, сервер автоматически отправляет данные всем подписанным клиентам.

### Ограничения GraphQL

- Нет встроенного кэширования: В отличие от REST (где кэшируются URL), GraphQL требует ручной настройки кэша (например,
  через Apollo Client).
- Сложность запросов: Клиент может отправить слишком сложный запрос (например, с глубокой вложенностью), что нагрузит
  сервер.
- Проблема N+1: Если запрашиваются связанные данные, сервер может сделать много запросов к БД.

### Инструменты для работы с GraphQL

Серверные

- Apollo Server (Node.js)
- GraphQL Yoga (упрощенный сервер)
- Hasura (GraphQL поверх PostgreSQL)

Клиентские

- Apollo Client (React/Vue)
- Relay (оптимизирован для Facebook)
- URQL (легковесная альтернатива)

## RPC (Remote Procedure Call)

## gRPC

## SOAP (Simple Object Access Protocol)

SOAP - это протокол обмена структурированными сообщениями. Формат данных - Soap-XML.
Может использоваться с любым протоколом прикладного уровня (SMTP, FTP, HTTP).
Для описания SOAP сервисов используется WSDL (Web Services Description Language) - язык описания веб-сервисов и доступа
к ним, основанный на XML.

STATEFUL

```
<binding type="bookPortType" name="bookBind">
  <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
  <operation name="getBook">
    <soap:operation soapAction="getBook"/> 
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="iteral"/>
      </output>
  </operation>
</binding>
<service name="Hello Service">
  <port binding="bookBind" name="bookPort">
    <soap:address location="http://localhost/bookservice"/>
  </port>
</service>
```

## tRPC

## WebSocket

## SSE (Server-Sent Events)

## Webhook

## MQTT

## AMQP

## CORBA

# Макро-архитектура серверных веб приложений

# Микро-архитектура серверных веб приложений

- **MVC (Model-View-Controller)**

  Описание: Это классическая архитектура, разделяющая приложение на три основные компоненты:  модель, представление и
  контроллер. Она используется для улучшения читаемости кода и разделения бизнес-логики от представления.
  Роль компонентов:
  Model (Модель): отвечает за данные и логику приложения, включая работу с базой данных.
  View (Представление): отвечает за отображение данных пользователю.
  Controller (Контроллер): управляет запросами от клиента, обновляет модель и выбирает подходящее представление для
  отображения.
  Пример: В Java это может быть Spring MVC, в Python — Django или Flask (с дополнительным паттерном MVC).

---

- **MVVM (Model-View-ViewModel)**

  Описание: Архитектурный паттерн, который часто используется в разработке приложений с пользовательскими интерфейсами,
  например, в приложениях на WPF или Xamarin. В веб-разработке MVVM используется в сочетании с JavaScript-фреймворками.
  Роль компонентов:
  Model: хранит данные приложения.
  View: отображает данные пользователю (UI).
  ViewModel: абстракция, которая связывает данные модели с представлением, обрабатывает бизнес-логику, но не имеет
  собственного UI.
  Пример: В веб-разработке это может быть Angular, где компоненты (ViewModel) связываются с представлением (HTML) и
  моделью (данными).

---

- **MVP (Model-View-Presenter)**

  Описание: Архитектурный паттерн, который схож с MVC, но с изменениями в роли компонентов. Presenter в этом случае
  отвечает за взаимодействие с представлением и обработку пользовательских действий.
  Роль компонентов:
  Model: данные и бизнес-логика.
  View: отображение данных пользователю.
  Presenter: принимает данные от модели, обновляет представление и обрабатывает события от представления.
  Пример: Этот паттерн используется в некоторых JavaScript-фреймворках, таких как GWT (Google Web Toolkit).

---

- **Layered Architecture (Многослойная архитектура)**

  Описание: Это подход, при котором приложение делится на несколько слоев, каждый из которых отвечает за определенную
  часть работы, например, представление, бизнес-логику, доступ к данным и т. д.
  Роль компонентов:
  Presentation Layer (Слой представления): отвечает за взаимодействие с пользователем, например, веб-страницы или API.
  Business Layer (Слой бизнес-логики): содержит логику приложения.
  Data Access Layer (Слой доступа к данным): взаимодействует с базой данных.
  Пример: Это может быть использовано в Spring с разделением на контроллеры, сервисы и репозитории.

---

- **Service-Oriented Architecture (SOA)**

  Описание: Архитектурный стиль, где приложение делится на сервисы, каждый из которых выполняет отдельную задачу. Эти
  сервисы взаимодействуют друг с другом через стандартизированные интерфейсы.
  Роль компонентов:
  Сервисы: независимые компоненты, выполняющие конкретные операции, например, обработка платежей, авторизация и т. д.
  Клиенты: взаимодействуют с сервисами через стандартные протоколы (например, HTTP).
  Пример: Используется в крупных распределенных системах и может быть реализована через REST API или SOAP.

---

- **Microservices Architecture**

  Описание: Это архитектурный стиль, в котором приложение разделяется на независимые микросервисы, каждый из которых
  выполняет отдельную задачу и может быть развернут и масштабирован независимо.
  Роль компонентов:
  Микросервисы: каждый микросервис отвечает за одну бизнес-логику (например, управление пользователями, обработка
  заказов, оплата).
  API Gateway: шлюз, который управляет взаимодействием между клиентами и микросервисами.
  Пример: В Spring Boot или Node.js можно использовать Spring Cloud или Express.js для реализации микросервисов.

---

- **Event-Driven Architecture (EDA)**

  Описание: В этой архитектуре взаимодействие между компонентами происходит через события. Каждый компонент слушает
  события и реагирует на них.
  Роль компонентов:
  Events: события, которые инициируют действия (например, создание заказа или обновление данных).
  Event Handlers: обработчики событий, которые выполняют действия, например, обновление базы данных.
  Event Bus: система, через которую события передаются между компонентами.
  Пример: Может быть реализована с использованием Kafka или RabbitMQ для передачи сообщений между компонентами.

---

- **Hexagonal Architecture (Ports and Adapters)**

  Описание: Это архитектурный паттерн, который разделяет бизнес-логику от внешних зависимостей    (например, базы
  данных, интерфейсы пользователя, сторонние сервисы). Основная цель — сделать бизнес-логику независимой от внешних
  технологий.
  Роль компонентов:
  Core (Основная логика): бизнес-логика, которая не зависит от технологий.
  Ports: интерфейсы для связи с внешними мирами (например, REST API).
  Adapters: компоненты, которые преобразуют данные между внешними мирами и портами.
  Пример: Реализуется в Spring Boot или Django с четким разделением бизнес-логики и внешних интерфейсов.

---

- **Serverless Architecture**

  Описание: В серверлесс-архитектуре приложение делится на небольшие функции или обработчики, которые выполняются в
  облаке, не требуя управления серверами.
  Роль компонентов:
  Функции: небольшие функции, которые выполняются на сервере по запросу. Каждая функция выполняет конкретную задачу (
  например, обработка запроса, отправка уведомления).
  API Gateway: шлюз для управления запросами, который передает их на соответствующие функции.
  Пример: Используется в AWS Lambda, Azure Functions и других облачных сервисах.

---
Каждая из этих архитектур может использоваться в зависимости от требований проекта:

MVC, MVVM, MVP — это классы архитектур, которые разделяют логику приложения, что облегчает поддержку и развитие.
SOA, Microservices и Event-Driven — это архитектуры для построения более сложных распределенных систем.
Hexagonal и Serverless архитектуры помогают в создании приложений, которые легко масштабируются и интегрируются с
другими системами.
Выбор архитектуры зависит от сложности приложения, требуемой масштабируемости и специфики бизнес-логики.

https://stackoverflow.com/questions/34130036/how-to-understand-restful-api-is-stateless

