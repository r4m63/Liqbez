UIComponent
	это базовый класс для всех компонентов UI
UIViewRoot
	это корневой компонент для представления
	управляет иерархией компонентов
    	все другие компоненты добавляются как дочерние элементы
    	управляет состоянием представления
    	сохраняет информацию о состоянии компонентов
FacesServlet
	сервлет - обрабатывает запросы и управляет жизненным циклом JSF-приложения
	центральный элементом в архитектуре
	обрабатывает все HTTP-запросы
     	отвечает за инициализацию JSF,
     	управление жизненным циклом компонентов,
     	обработку событий и рендеринг представлений.

===============================================================================
Полный жизненный цикл JSF

Получение запроса (FacesServlet)
	запрос -> FacesServlet
	FacesServlet -> инициализирует необходимые компоненты и контексты для обработки запроса

Восстановление представления (Restore View)
	FacesServlet -> проверяет, существует ли уже сохраненное состояние представления
	создается новый объект UIViewRoot
	else:
	FacesServlet восстанавливает его из сохраненного состояния

Обработка ввода (Apply Request Values)
	Эти значения устанавливаются в свойства бинов

Проверка данных (Process Validations)
	валидация
	
Обновление модели (Update Model Values)
	валидация -> JSF обновляет значения в модели
	Значения, введенные пользователем, копируются в соответствующие поля бина

Обработка событий (Invoke Application)
	JSF обрабатывает действия, связанные с пользовательским интерфейсом.
	Вызываются методы, привязанные к действиям компонентов
	
Подготовка представления (Render Response)
	JSF готовит ответ для пользователя.
	JSF создает HTML-код


    Когда приходит HTTP-запрос, JSF создает новый экземпляр UIViewRoot
    В процессе восстановления состояния (Restore View) JSF восстанавливает состояние компонентов
    Сохраняет информацию о том, какие данные были введены пользователем
    В процессе обработки событий UIViewRoot управляет взаимодействием между компонентами и их состояниями
    Когда все операции завершены, UIViewRoot генерирует HTML-код для ответа, который будет отправлен клиенту.
===============================================================================





- компонентная модель, каждый UI элемент - компонент
- компоненты могут быть простыми (кнопки, текстовые поля) или сложными (таблицы, формы)
- JSF управляет состоянием компонентов, сохраняя данные между запросами
- компоненты определяются с помощью тегов, которые могут иметь различные атрибуты для настройки их поведения и внешнего вида
- JSF-компоненты могут быть стилизованы с помощью CSS и могут быть адаптивными
- компоненты могут генерировать события, такие как нажатие кнопки или изменение поля ввода, которые могут быть обработаны в бэкенде

    UIComponent (методы для управления состоянием, рендерингом и обработкой событий)
    ||||||
    UIInput: Абстрактный класс для компонентов ввода (например, текстовые поля, флажки)
    UICommand: Абстрактный класс для компонентов, которые инициируют действия 
    UIOutput: Класс для компонентов, которые отображают данные (например, текстовые метки)
    UIForm: Компонент, который группирует другие компоненты ввода и управляет их состоянием

    Дополнительные библиотеки компонентов
    RichFaces: богатый набор компонентов для создания интерактивных веб-приложений
    IceFaces: ориентированная на создание AJAX-приложений






Конвертеры и валидаторы данных.
	Конвертеры - для преобразования данных между различными форматами. строку в объект и обратно.
	@FacesConverter("myConverter")
    public class MyConverter implements Converter {
        @Override
        public Object getAsObject(FacesContext context, UIComponent component, String value) {
            // Логика преобразования строки в объект
            if (value == null || value.isEmpty()) {
                return null;
            }
            return new MyObject(value); // Пример преобразования
        }

        @Override
        public String getAsString(FacesContext context, UIComponent component, Object value) {
            // Логика преобразования объекта в строку
            if (value == null) {
                return "";
            }
            return ((MyObject) value).toString(); // Пример преобразования
        }
    }
    <h:inputText value="#{bean.myObject}" converter="myConverter" />

    Валидаторы - для проверки корректности данных, введенных пользователем.
    @FacesValidator("myValidator")
    public class MyValidator implements Validator {
        @Override
        public void validate(FacesContext context, UIComponent component, Object value) {
            // Логика валидации
            if (value == null || !(value instanceof String) || ((String) value).isEmpty()) {
                FacesMessage msg = new FacesMessage("Validation failed", "Value cannot be empty");
                throw new ValidatorException(msg);
            }
            // Дополнительные проверки
        }
    }
    <h:inputText value="#{bean.myValue}" validator="myValidator" />




    

MANAGED BEANS
(@RequestScoped)        создается для обработки одного HTTP-запроса и уничтожается после завершения обработки этого запроса

(@SessionScoped)        будет существовать до тех пор, пока сессия не завершится (например, пользователь не выйдет из системы или сессия не истечет)

(@ViewScoped)           будет существовать до тех пор, пока пользователь находится на этой странице

(@ApplicationScoped)    создается один раз для всего приложения и будет существовать до тех пор, пока приложение не будет остановлено

(@Dependent)            создается каждый раз, когда он инъектируется в другой бин, не имеет своего жизненного цикла и уничтожается вместе с бином, в который он был инъектирован




    
Доступ к БД из Java-приложений. Протокол JDBC, формирование запросов, работа с драйверами СУБД.
    import java.sql.Connection;
    import java.sql.DriverManager;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.sql.SQLException;

    public class JDBCExample {
        public static void main(String[] args) {
            String url = "jdbc:mysql://localhost:3306/mydatabase";
            String user = "root";
            String password = "password";
            try {
                Class.forName("com.mysql.cj.jdbc.Driver");
                try (Connection connection = DriverManager.getConnection(url, user, password)) {
                    String query = "SELECT * FROM users WHERE age > ?";
                    try (PreparedStatement preparedStatement = connection.prepareStatement(query)) {
                        preparedStatement.setInt(1, 18);
                        ResultSet resultSet = preparedStatement.executeQuery();
                        while (resultSet.next()) {
                            String name = resultSet.getString("name");
                            int age = resultSet.getInt("age");
                            System.out.println("Name: " + name + ", Age: " + age);
                        }
                        resultSet.close();
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
    }



Библиотеки ORM Hibernate и EclipseLink. Особенности, API, сходства и отличия.
    Hibernate
        поддерживает множество баз данных + первый и второй уровень кэширования
        различные способы конфигурации (XML, аннотации, Java-код)
        HQL — позволяет писать запросы, используя объекты и их свойства вместо таблиц и столбцов
        хорошо интегрируется с Spring Framework
        поддерживает Criteria API для создания типобезопасных запросов
    Основные API
        Session: Основной интерфейс для взаимодействия с базой данных. Используется для операций CRUD
        SessionFactory: Интерфейс для создания объектов Session
        Transaction: Интерфейс для управления транзакциями
        Query: Интерфейс для выполнения HQL и JPQL-запросов
        Criteria: API для создания запросов с использованием объектно-ориентированного подхода
    EclipseLink
        официальная реализацией спецификации JPA и поддерживает все ее функции
        Поддержка NoSQL
        поддерживает множество типов данных, включая сложные и пользовательские типы
        хорошо интегрируется с Java EE
    Основные API
        EntityManager: Основной интерфейс для взаимодействия с контекстом персистенции
        EntityTransaction: Интерфейс для управления транзакциями
        Query: Интерфейс для выполнения JPQL-запросов
        CriteriaBuilder: Интерфейс для создания запросов с использованием Criteria API
    Сходства
        Реализация JPA
        Поддержка транзакций
        Кэширование
        Поддержка HQL/JPQL
    Отличия
        Поддержка NoSQL: EclipseLink
        Интеграция с Java EE:
            Hibernate: Может использоваться как в Java EE, так и в Java SE приложениях, но не является частью Java EE
            EclipseLink: Является частью Java EE и лучше интегрируется с этой платформой
        Кэширование:
            Hibernate: Предлагает более гибкие механизмы кэширования с поддержкой первого и второго уровней кэширования
            EclipseLink: Также поддерживает кэширование, но его механизмы могут быть менее гибкими по сравнению с Hibernate
        Производительность:
            Hibernate: В некоторых случаях может быть медленнее из-за более сложных механизмов кэширования и обработки
            EclipseLink: Может иметь преимущества в производительности в определенных сценариях, особенно в приложениях Java EE
        Документация и сообщество:
            Hibernate: имеет более широкое сообщество и обширную документацию, что делает его более доступным для разработчиков.
            EclipseLink: Хотя документация также хороша, сообщество может быть менее активным по сравнению с Hibernate.

