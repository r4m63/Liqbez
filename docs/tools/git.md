# GIT

Git - распределенная система контроля версий, потому что в ней не требуется центральный сервер, у каждого разработчика
локальная версия репозитория. В реальных проектах используют сервер для удобства обмена данными, сервер не выполняет
никакой умной работы, это только центральный пункт обмена данными.

git-bash-prompt
oh-my-zsh

## Команды

### Настройка Git

`git config`

- `--system`
- `--global`
- `--local`
- `--list`

`git config user.email "email@example.com"`

`git config user.name "Name"`

### Создание репозитория

`git init`

### Просмотр состояния и изменений

`git status` Отображает состояние рабочей директории и индекса (staging area), показывая: Отслеживаемые и
неотслеживаемые файлы, Изменения готовые к коммиту, Состояние ветки, Конфликты слияния (если есть)

- `git status -v` или `--verbose` Показать дополнительные подробности (повторный флаг увеличивает детализацию)
- `git status -s` или `--short` Краткий формат вывода
- `git status -b` или `--branch` Показать информацию о ветке и ее связи с удаленным репозиторием
- `git status --long` Полный формат вывода (по умолчанию)

`git diff` Показывает различия между: Рабочей директорией и индексом, Индексом и последним коммитом, Двумя коммитами,
Двумя ветками, Двумя файлами

- `git diff` Сравнение рабочей директории с индексом
- `git diff --staged` или `--cached` Сравнение индекса с последним коммитом
- `git diff HEAD` Сравнение рабочей директории с последним коммитом
- `git diff <commit>` Сравнение рабочей директории с указанным коммитом
- `git diff <commit1> <commit2>` Сравнение двух коммитов
- `git diff <branch1> <branch2>` Сравнение двух веток

### Добавление и фиксация изменений

`git add <file>` добавляет изменения из рабочего каталога в индекс

- `git add .` все файлы в текущей директории
- `git add -A` все изменения (добавления, удаления, перемещения)
- `git add -u` только отслеживаемые файлы

`git commit` фиксирует все подготовленные изменения в истории Git

- `git commit -m "Сообщение"` сообщение коммита
- `git commit -am "Сообщение"` -a заменяет (add .)
- `git commit --amend` позволяет изменить последний коммит (можно исправить сообщение или добавить забытые файлы)
- `--no-edit` не открывать редактор для сообщения коммита
- `--date=now` перезаписать дату
- `--author="Name <email>"` изменить автора
- `--reset-author` сбросить автора на текущего

### Работа с ветками

`git branch` – показать список веток.

`git branch <name>` – создать новую ветку.

- `git branch -d <name>` – удалить ветку.

`git checkout <branch>` – переключиться на ветку.

- `git checkout -b <new-branch>` – создать и переключиться на новую ветку.

`git switch <ветка>` – переключиться на ветку (альтернатива checkout).

`git merge <branch>` – слить изменения из указанной ветки.

`git rebase <branch>` – переносит изменения из одной ветки на другую, переписывая историю коммитов. В отличие от merge,
который создаёт новый коммит слияния, rebase "перемещает" ваши коммиты на вершину другой ветки

- `git rebase -i HEAD~3` последние 3 коммита

`git cherry-pick <коммит>` – применить один коммит в текущую ветку.

- `git cherry-pick feature-branch~2` - Берём предпоследний коммит из feature-branch
- `git cherry-pick abc1234..def5678` - Все коммиты между abc1234 и def5678 (исключая abc1234)

### История и логи

`git log` показывает историю коммитов в репозитории

- `git log --oneline` Краткий однострочный вывод
- `git log --graph` С ASCII-графом ветвлений
- `git log --decorate` Показывает ветки и теги
- `git log --pretty=format:"%h - %an, %ar : %s` Кастомный формат
-

`git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(auto)%d%C(reset)' --all`

`git show <commit>` Просмотр последнего коммита

- `git show abc123` По хэшу (первые 6-7 символов достаточно)
- `git show HEAD~2` Предпредпоследний коммит
- `git show feature-branch` Последний коммит в ветке
- `git show abc123..def456` сравнить два коммитам
- `git show 123abc:src/app.js` просмотр файла из коммита

`git blame <file>` показывает, кто и когда последний раз изменял каждую строку в файле

### Отмена изменений

`git revert <commit>` создаёт новый коммит откат, который отменяет изменения из указанного коммита, не удаляет коммит из
истории, а вносит противоположные изменения, чтобы “перекрыть” его эффект поверх старого коммита

`git reset <commit>` отменяет, удаляет коммиты. Работает на трех уровнях и позволяет управлять состоянием репозитория,
индексом и рабочей директорией

- `git reset --soft <commit>` сбрасывает только указатель HEAD, с сохранением удаленного в индекс (Не изменяет индекс (
  staging area), Не изменяет рабочие файлы)
- `git reset --mixed <commit>` сбрасывает HEAD и индекс (Сбрасывает индекс, Сохраняет изменения в рабочих файлах)
- `git reset --hard <commit>` сбрасывает HEAD, индекс и рабочую директорию (Сбрасывает индекс, Сбрасывает рабочие файлы)
- `git reset @~2` удалить последние 2 коммита

Отмена сброса:
`git reflog` Найти старый хэш
`git reset <старый-хэш>` Вернуться к нему

`git restore <file>` Отменять незакоммиченные изменения в рабочих файлах, Удалять файлы из staging area (индекса),
Восстанавливать файлы из определённого коммита

`git clean -dxf` для удаления неотслеживаемых файлов из рабочей директории

- `-n` Показать, какие файлы будут удалены (пробный запуск)
- `-f` Принудительное удаление (обязательно для реального выполнения)
- `-d` Удалять также неотслеживаемые директории
- `-x` Удалять также игнорируемые файлы (из .gitignore)
- `-X` Удалять ТОЛЬКО игнорируемые файлы
- `-i` Интерактивный режим

### Удаленные репозитории

`git clone <url>`

`git remote`

`git remote -v`

`git remote add <name> <url>`

`git fetch <remote>`

`git pull <remote> <branch>`

`git push <remote> <branch>`

`git push -u <remote> <branch>`

### Теги

`git tag` используются для пометки важных моментов в истории коммитов

...

### Сохранение временных изменений

`git stash` позволяет временно сохранить незакоммиченные изменения, чтобы вы могли переключиться на другую ветку или
выполнить другие операции, а затем вернуть эти изменения обратно

- `git stash push -m "..."` сохранить с описанием
- `git stash pop` Вернуть последние сохранённые изменения (и удалить из stash)
- `git stash list` Просмотреть список сохранённых stash'ей
- `git stash apply <stash>` Вернуть конкретный stash (без удаления)
- `git stash drop stash@{1}` Удалить конкретный
- `git stash clear ` Удалить все

### Дополнительные

`git submodule add <url>`

`git submodule update --init --recursive`

`git help <команда>` – получить справку по команде.

`git reflog` – показать историю всех изменений, включая удаленные коммиты.

`git bisect` – поиск коммита, вызвавшего ошибку.

`git gc` – очистка репозитория (удаление старых объектов).

`git fsck` – проверка целостности репозитория.

## Области GIT

1. Working directory

   Файлы, которые лежат в файловой системе

2. Index (в .git/index)

   Содержит изменения, которые будут включены в следующий коммит.

   Контролирует, какие изменения попадут в следующий коммит

3. Repository (в .git) - база данных всех версий проекта

   Содержит полную историю коммитов, веток, тегов

## .git

## .github

## .gitattribute

## Сброс кэша

Если `.gitignore` не применяется - значит есть файлы которые git уже отслеживает.
Нужно удалить файлы из индекса

```bash
git rm -r --cached .
git add .
git commit -m "Restore cached + .gitignore"
git push
```

## Как писать хорошие коммиты

### Источники

В качестве основы
используется [Angular Git commit Message Convention](https://github.com/angular/angular/blob/main/CONTRIBUTING.md#-commit-message-format) -
это наиболее авторитетный источник. Все остальные вариации конвенций по коммитам ссылаются на эту.

Также достаточно авторитетным источником
является [conventionalcommits.org](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/)

### Шаблон коммита

Для оформления сообщения коммита следует использовать следующий шаблон:

    <type>(<scope>): <description>
    <BLANK LINE>
    <body> 
    <BLANK LINE>
    <footer>

Type, scope и description вместе составляют заголовок коммита (header).

- **Type** - тип коммита (рефакторинг, исправление багов, новая фича и т.п.)
- **Scope** - область действия (где были изменения). Это может быть отдельный файл, директория или затронутая часть
  проекта (rendering, routing и т.д.). Не обязательно для заполнения (но желательно).
- **Description** - описание сути коммита. Обычно отвечает на вопрос "что было изменено/добавлено/удалено?" Например:
  add comment section
- **Blank line** - пустая строка, ей отделяется тело коммита от заголовка, и тело от футера.
- **Body** - не обязательно для заполнения. Здесь обычно отвечают на вопрос "Зачем были изменения?" и "Почему сделаны
  именно такие изменения?" (почему не стоит делать по-другому).
- **Footer** - не обязательно для заполнения. Может содержать информацию о критических изменениях (breaking changes), а
  также является местом для указания задач из бэклога, GitHub issues, тикетов, и других проблем, которые этот коммит
  закрывает или с которыми он связан.

### Пример коммита

    chore: drop Node 6 from testing matrix
    
    see the issue for details on the typos fixed
    
    BREAKING CHANGE: dropping Node 6 which hits end of life in April
    closes issue #12

### Примеры заголовков коммитов

Плохо:

    Changed render method in Block

Лучше:

    refactor: Changed render method in Block

Хорошо:

    refactor(Block.ts): update render method

### Несколько коротких правил

1. Коммиты пишутся на английском языке.
2. Заголовок коммита пишется с маленькой буквы.
3. Точка в конце не ставится.
4. Длина заголовка не должна превышать 100 символов, а лучше 50. Подробности коммита выносятся в тело и футер.
5. Description начинается с глагола. Глагол указывается в настоящем времени, например: add, update, improve, remove (не
   added, updates) и тд.

### Как писать коммит при Pull Request

1. Сообщение коммита при merge PR формируется по такому же принципу как описано выше.
2. В конец заголовка коммита включается номер PR в скобочках после основного сообщения. Например:
   ``refactor(Block.ts): update render method (#67)``
3. Все сообщения коммитов из сливаемой ветки вносятся в тело коммита.

   docs(readme.md): add documentation about project (#3)

    * docs(workFlow.md): fix name of developing branch
    * chore(package.json): add commitlint to devDependencies
      Some extra notes.

### Тип коммита

* **feat** - используется при добавлении новой функциональности.
* **fix** - исправление багов.
* **refactor** - изменения кода, которые не исправляет баги и не добавляют функционал.
* **chore** - изменение конфигов, системы сборки, обновление зависимостей и т.д.
* **test** - всё, что связано с тестированием.
* **style** - исправление опечаток, изменение форматирования кода (переносы, отступы, точки с запятой и т.п.) без
  изменения смысла кода.
* **docs** - изменения только в документации.

Эти типы расширяют вышеописанные, но их использовать не обязательно:

* **perf** - изменения кода, повышающие производительность.
* **build** - изменения, влияющие на систему сборки или внешние зависимости (webpack, npm).
* **ci** - изменения в файлах конфигурации.

### BREAKING CHANGE (критические изменения)

BREAKING CHANGE: указывается в футере и автоматически добавляется в конец заголовка. Критические изменения - это
изменения, нарушающие обратную совместимость. Может быть частью коммита любого типа.

Должен начинаться с фразы `BREAKING CHANGE:`, за которой следует краткое изложение критического изменения, пустая
строка и подробное описание критического изменения.

## Как правильно создавать ветки и вести репозиторий

- Git Flow
- GitLab Flow
- GitРги Flow
- Trunk-Based Development
- Forking Workflow
- Centralized Workflow
