# Архитектуры клиент-серверного взаимодействия веб приложений

- **REST** — самый распространенный подход, используется в большинстве современных приложений
---
- **GraphQL** — позволяет клиентам запрашивать только нужные данные

    **Описание:** Это язык запросов для API, который позволяет клиенту точно запрашивать только те данные, которые ему нужны, и ничего лишнего.
    **Основные особенности:**
    - Гибкость запросов: Клиенты могут запросить только нужные данные, что снижает объем  передаваемых данных.
    - Единый endpoint: Все запросы (например, получение данных, их создание, обновление и удаление)   происходят через один endpoint.
    - Изменение структуры данных на лету: Клиенты могут легко изменять структуру получаемых данных,   что делает API гибким и удобным для использования.
    
    **Пример:**

    ```java
    example();
    ```

- **gRPC** — используется для высокопроизводительных приложений с двусторонней связью
---
- **SOAP** — более старый и тяжелый протокол, используется в корпоративных системах
---
- **WebSockets** — идеально подходит для приложений в реальном времени
---
- **JSON-RPC / XML-RPC** — более легковесные протоколы для удаленных вызовов процедур
---
- **Server-Sent Events** — для простых уведомлений в реальном времени
---
- **OData** — используется для работы с данными с возможностью фильтрации и сортировки
---
Выбор архитектуры клиент-серверного взаимодействия зависит от требований к приложению:

REST и GraphQL — подходят для веб-приложений с запросами/ответами на основе HTTP.
WebSockets и gRPC — используются для приложений, которые требуют двусторонней связи и высокой производительности.
SSE и Polling — применяются для обновлений в реальном времени, с SSE как предпочтительным вариантом для однонаправленных потоков данных.
SOAP — подходит для корпоративных решений с высокой степенью безопасности и надежности.


# Архитектуры серверных веб приложений

- **MVC (Model-View-Controller)**

    Описание: Это классическая архитектура, разделяющая приложение на три основные компоненты:  модель, представление и контроллер. Она используется для улучшения читаемости кода и     разделения бизнес-логики от представления.
    Роль компонентов:
    Model (Модель): отвечает за данные и логику приложения, включая работу с базой данных.
    View (Представление): отвечает за отображение данных пользователю.
    Controller (Контроллер): управляет запросами от клиента, обновляет модель и выбирает    подходящее представление для отображения.
    Пример: В Java это может быть Spring MVC, в Python — Django или Flask (с дополнительным     паттерном MVC).
---
- **MVVM (Model-View-ViewModel)**

    Описание: Архитектурный паттерн, который часто используется в разработке приложений с   пользовательскими интерфейсами, например, в приложениях на WPF или Xamarin. В веб-разработке  MVVM используется в сочетании с JavaScript-фреймворками.
    Роль компонентов:
    Model: хранит данные приложения.
    View: отображает данные пользователю (UI).
    ViewModel: абстракция, которая связывает данные модели с представлением, обрабатывает   бизнес-логику, но не имеет собственного UI.
    Пример: В веб-разработке это может быть Angular, где компоненты (ViewModel) связываются с   представлением (HTML) и моделью (данными).
---
- **MVP (Model-View-Presenter)**

    Описание: Архитектурный паттерн, который схож с MVC, но с изменениями в роли компонентов.   Presenter в этом случае отвечает за взаимодействие с представлением и обработку   пользовательских действий.
    Роль компонентов:
    Model: данные и бизнес-логика.
    View: отображение данных пользователю.
    Presenter: принимает данные от модели, обновляет представление и обрабатывает события от    представления.
    Пример: Этот паттерн используется в некоторых JavaScript-фреймворках, таких как GWT (Google     Web Toolkit).
---
- **Layered Architecture (Многослойная архитектура)**

    Описание: Это подход, при котором приложение делится на несколько слоев, каждый из которых  отвечает за определенную часть работы, например, представление, бизнес-логику, доступ к  данным и т. д.
    Роль компонентов:
    Presentation Layer (Слой представления): отвечает за взаимодействие с пользователем,    например, веб-страницы или API.
    Business Layer (Слой бизнес-логики): содержит логику приложения.
    Data Access Layer (Слой доступа к данным): взаимодействует с базой данных.
    Пример: Это может быть использовано в Spring с разделением на контроллеры, сервисы и    репозитории.
---
- **Service-Oriented Architecture (SOA)**

    Описание: Архитектурный стиль, где приложение делится на сервисы, каждый из которых выполняет отдельную задачу. Эти сервисы взаимодействуют друг с другом через стандартизированные интерфейсы.
    Роль компонентов:
    Сервисы: независимые компоненты, выполняющие конкретные операции, например, обработка   платежей, авторизация и т. д.
    Клиенты: взаимодействуют с сервисами через стандартные протоколы (например, HTTP).
    Пример: Используется в крупных распределенных системах и может быть реализована через REST  API или SOAP.
---
- **Microservices Architecture**

    Описание: Это архитектурный стиль, в котором приложение разделяется на независимые микросервисы, каждый из которых выполняет отдельную задачу и может быть развернут и масштабирован независимо.
    Роль компонентов:
    Микросервисы: каждый микросервис отвечает за одну бизнес-логику (например, управление   пользователями, обработка заказов, оплата).
    API Gateway: шлюз, который управляет взаимодействием между клиентами и микросервисами.
    Пример: В Spring Boot или Node.js можно использовать Spring Cloud или Express.js для    реализации микросервисов.
---
- **Event-Driven Architecture (EDA)**

    Описание: В этой архитектуре взаимодействие между компонентами происходит через события. Каждый компонент слушает события и реагирует на них.
    Роль компонентов:
    Events: события, которые инициируют действия (например, создание заказа или обновление  данных).
    Event Handlers: обработчики событий, которые выполняют действия, например, обновление базы  данных.
    Event Bus: система, через которую события передаются между компонентами.
    Пример: Может быть реализована с использованием Kafka или RabbitMQ для передачи сообщений   между компонентами.
---
- **Hexagonal Architecture (Ports and Adapters)**

    Описание: Это архитектурный паттерн, который разделяет бизнес-логику от внешних зависимостей    (например, базы данных, интерфейсы пользователя, сторонние сервисы). Основная цель — сделать   бизнес-логику независимой от внешних технологий.
    Роль компонентов:
    Core (Основная логика): бизнес-логика, которая не зависит от технологий.
    Ports: интерфейсы для связи с внешними мирами (например, REST API).
    Adapters: компоненты, которые преобразуют данные между внешними мирами и портами.
    Пример: Реализуется в Spring Boot или Django с четким разделением бизнес-логики и внешних   интерфейсов.
---
- **Serverless Architecture**

    Описание: В серверлесс-архитектуре приложение делится на небольшие функции или обработчики,     которые выполняются в облаке, не требуя управления серверами.
    Роль компонентов:
    Функции: небольшие функции, которые выполняются на сервере по запросу. Каждая функция   выполняет конкретную задачу (например, обработка запроса, отправка уведомления).
    API Gateway: шлюз для управления запросами, который передает их на соответствующие функции.
    Пример: Используется в AWS Lambda, Azure Functions и других облачных сервисах.
---
Каждая из этих архитектур может использоваться в зависимости от требований проекта:

MVC, MVVM, MVP — это классы архитектур, которые разделяют логику приложения, что облегчает поддержку и развитие.
SOA, Microservices и Event-Driven — это архитектуры для построения более сложных распределенных систем.
Hexagonal и Serverless архитектуры помогают в создании приложений, которые легко масштабируются и интегрируются с другими системами.
Выбор архитектуры зависит от сложности приложения, требуемой масштабируемости и специфики бизнес-логики.

